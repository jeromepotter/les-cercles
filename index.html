<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LES CERCLES</title>
    <style>
        :root {
            /* LIGHT MODE (Default) */
            --bg-color: #e8e6e1; 
            --ink-color: #333333; 
            --accent-orange: #cf6325;
            --accent-blue: #364a59;
            --accent-red: #f04e23;
            --panel-bg: #f4f4f2;
            --border: 1px solid #bbb;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* DARK MODE overrides */
        body.dark-mode {
            --bg-color: #1a1a1a; 
            --ink-color: #e0e0e0;
            --panel-bg: #2a2a2a;
            --border: 1px solid #444;
            --shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        @font-face {
            font-family: 'Helvetica Neue';
            src: local('Helvetica Neue'), local('Arial'), sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--ink-color);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden; /* Prevent scroll */
            width: 100vw;
            height: 100dvh;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.3s, color 0.3s;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            cursor: crosshair;
            touch-action: none; 
        }

        /* HUD & UI */
        #hud-top {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: 500;
            letter-spacing: 0.5px;
            z-index: 10;
            justify-content: space-between; 
        }

        h1.title {
            margin: 0;
            font-weight: 700;
            font-size: 1.2em;
            letter-spacing: 1px;
            display: none; 
        }
        @media (min-width: 768px) {
            h1.title { display: block; }
            #hud-top { justify-content: flex-start; }
        }

        .hud-item {
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        .hud-item:hover { opacity: 1; }

        select.midi-select {
            background: transparent;
            color: var(--ink-color);
            border: none;
            border-bottom: 1px solid #999;
            padding: 2px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            margin-left: 0;
            outline: none;
            max-width: 120px;
            cursor: pointer;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .volume-control label {
            font-size: inherit;
            font-weight: inherit;
            font-family: inherit;
            letter-spacing: inherit;
            white-space: nowrap;
        }

        .volume-control input[type=range] {
            width: 90px;
        }

        /* CONTROLS BAR */
        #controls-bar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            pointer-events: none; 
            z-index: 20;
        }

        .controls-row {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 20px;
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .macro-slider-container label {
            font-size: 0.85em;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* BUTTONS */
        .btn-circle {
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            border-radius: 50%;
            color: var(--ink-color);
            font-size: 1.8em;
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0.8;
            border: 1px solid rgba(0,0,0,0.1); 
            transition: opacity 0.2s, transform 0.1s;
        }
        .btn-circle:active { transform: scale(0.95); background: rgba(0,0,0,0.05); }

        .btn-text {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            font-weight: 600;
            color: var(--ink-color);
            opacity: 0.7;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 1px;
            padding: 8px 10px; 
            white-space: nowrap;
        }
        .btn-text:active { background: rgba(0,0,0,0.05); opacity: 1; }
        .btn-active { color: var(--accent-orange); opacity: 1; border-bottom: 2px solid var(--accent-orange); }
        .btn-text:disabled { opacity: 0.3; cursor: not-allowed; }

        /* PLANET LIST */
        #planet-list-wrap {
            --chip-size: 18px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 90vw;
            overflow-x: auto;
            z-index: 15;
            overflow: hidden; 
}
        }

        #planet-list-wrap .planet-chip-btn {
            width: var(--chip-size, 16px);
            height: var(--chip-size, 16px);
            aspect-ratio: 1 / 1;
            flex: 0 0 var(--chip-size, 16px);
            box-sizing: border-box;
            border-radius: 999px;
            border: 1px solid rgba(0,0,0,0.2);
            background: var(--panel-bg);
            color: var(--ink-color);
            font-size: 0.9em;
            line-height: 1;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        #planet-list {
            display: flex;
            gap: 8px;
            align-items: center;
            max-width: 100%;
            overflow-x: auto;
            padding: 6px; 
            scrollbar-width: none; 

        }

        .planet-chip {
            width: var(--chip-size, 16px);
            height: var(--chip-size, 16px);
            aspect-ratio: 1 / 1;
            flex: 0 0 var(--chip-size, 16px);
            box-sizing: border-box;
            border-radius: 999px;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.1);
            transition: transform 0.2s;
            flex-shrink: 0;
            display: inline-block;
        }
        .planet-chip.active { box-shadow: 0 0 0 2px var(--ink-color); transform: scale(1.3); }

        #transpose-label {
            display: inline-block;
            width: 3ch;
            text-align: center;
        }

        /* SLIDERS */
        .macro-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 100px;
            height: 4px;
            background: #ccc;
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; 
            height: 18px;
            border-radius: 50%;
            background: var(--ink-color);
            cursor: pointer;
            border: 2px solid var(--bg-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* PANELS */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: var(--panel-bg);
            border: var(--border);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            padding: 20px;
            z-index: 100;
            border-radius: 4px;
        }

        .modal h2 {
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
            color: var(--ink-color);
            opacity: 0.6;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        input:not([type=range]), select {
            background: var(--bg-color);
            color: var(--ink-color);
            border: 1px solid #ccc;
            padding: 8px;
            font-family: inherit;
            width: 120px;
            border-radius: 3px;
            font-size: 16px; 
        }
        input[type=checkbox] { width: auto; }

        .btn-group { display: flex; gap: 10px; margin-top: 25px; }
        .btn-full { flex: 1; padding: 12px; cursor: pointer; border: 1px solid #ccc; background: var(--bg-color); color: var(--ink-color); font-weight: 600; font-size: 0.9em; border-radius: 3px; }
        .btn-danger { color: #d00; border-color: #ecc; }

        /* CIRCLE KEYS */
        .circle-keys-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0; }
        .key-circle {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid var(--ink-color);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            font-size: 0.75em; font-weight: bold; opacity: 0.5;
        }
        .key-circle.active { background: var(--ink-color); color: var(--bg-color); opacity: 1; }
        .key-circle.black-key { background: rgba(0,0,0,0.1); }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000; cursor: pointer;
        }

        /* --- MOBILE OPTIMIZATIONS --- */
        @media (max-width: 768px) {
            #hud-top { 
                top: 10px; left: 10px; right: 10px; 
                gap: 5px;
            }
            .hud-item { font-size: 0.75em; }
            
            select.midi-select {
                max-width: 80px;
                font-size: 0.9em;
                padding: 0;
                border: none;
                border-bottom: 1px solid #999;
            }

            #controls-bar {
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                background: rgba(255,255,255,0.1);
                backdrop-filter: blur(10px);
                padding: 10px 5px 15px 5px; 
                flex-direction: column-reverse; 
                gap: 12px;
                border-top: 1px solid rgba(0,0,0,0.05);
                box-sizing: border-box;
            }

            .control-group {
                width: 100%;
                justify-content: space-around; 
                gap: 2px;
            }
            
            input[type=range] { width: 70px; }
            .macro-slider-container label { font-size: 0.7em !important; }
            .volume-control input[type=range] { width: 70px; }

            .btn-text {
                font-size: 0.7em;
                padding: 8px 6px;
                border: 1px solid rgba(0,0,0,0.1);
            }
            
            #controls-bar {
                bottom: 15px;
                left: 10px;
                right: 10px;
            }

            .controls-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .modal { width: 85vw; }
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-size: 3em; letter-spacing: 4px; font-weight: 300; text-align: center;">LES CERCLES</h1>
        <p style="color: var(--ink-color); opacity: 0.5; margin-top: 10px; font-size: 0.8em;">CLICK TO INITIALIZE</p>
    </div>

    <input type="file" id="file-input" style="display: none;" accept=".json" onchange="handleFileLoad(this)">

    <div id="game-container">
        <div id="hud-top">
            <h1 class="title">LES CERCLES</h1>
            <div class="hud-item" onclick="toggleAudio()">AUDIO: <span id="audio-label">ON</span></div>
            <div class="hud-item" onclick="openGlobal()">SETTINGS</div>

            <div class="hud-item">
                <select id="midi-select" class="midi-select" onchange="MidiEngine.selectOutput(this.value)">
                    <option value="">MIDI...</option>
                </select>
            </div>

            <div class="hud-item volume-control">
                <label for="volume-range">VOL</label>
                <input id="volume-range" type="range" min="0" max="2" step="0.01" value="1" oninput="updateMasterVolume(this.value)">
            </div>
        </div>

        <canvas id="mainCanvas"></canvas>
        
        <div id="controls-bar">
            <div class="controls-row">
                <div class="control-group">
                    <button id="btn-play" class="btn-text" onclick="togglePlay()">PLAY</button>
                    <button id="btn-undo" class="btn-text" onclick="undoLastMove()" disabled>UNDO</button>
                    <button class="btn-text" onclick="clearAll()">CLEAR</button>
                    <button class="btn-text" onclick="syncRPMs()">SYNC</button>
                    <button class="btn-text" onclick="evenSpacePlanets()">EVEN</button>
                    <button class="btn-text" onclick="toggleSlingshot()">ORB</button>
                </div>

                <div class="control-group">
                    <button id="btn-dir" class="btn-text" onclick="toggleDirection()">CCW</button>

                    <div class="macro-slider-container">
                        <label>GATES: <span id="gate-label">1</span></label>
                        <input id="gate-range" type="range" min="1" max="32" step="1" value="1" oninput="updateGates(this.value)">
                    </div>

                    <div class="macro-slider-container">
                        <label>TRANSPOSE: <span id="transpose-label">0</span></label>
                        <input id="transpose-range" type="range" min="-7" max="7" step="1" value="0" oninput="updateGlobalTranspose(this.value)">
                    </div>

                    <button class="btn-text" onclick="randomizeGateTranspose()">RND</button>

                    <div class="macro-slider-container">
                        <label>SPEED</label>
                        <input id="speed-range" type="range" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateGlobalSpeed(this.value)">
                    </div>
                </div>
            </div>

            <div id="planet-list-wrap">
                <button class="planet-chip-btn" onclick="addPlanet()">+</button>
                <div id="planet-list"></div>
                <button class="planet-chip-btn" onclick="deleteLastPlanet()">-</button>
            </div>
        </div>

        <div id="planet-panel" class="modal">
            <div class="control-row">
                <label>Note</label>
                <select id="p-note"></select>
            </div>
            <div class="control-row">
                <label>RPM</label>
                <input type="number" id="p-rpm" step="0.1" min="0.1" max="100">
            </div>
            <div class="control-row">
                <label></label>
                <input type="range" id="p-rpm-range" min="0.1" max="100" step="0.01">
            </div>
            <div class="control-row">
                <label>Volume</label>
                <input type="range" id="p-vol" min="0" max="1" step="0.01">
            </div>
            <div class="btn-group">
                <button class="btn-full btn-danger" onclick="deletePlanet()">DELETE</button>
                <button class="btn-full" onclick="closePanel('planet-panel')">DONE</button>
            </div>
        </div>

        <div id="trigger-panel" class="modal">
            <h2>Trigger Settings</h2>
            <div class="control-row">
                <label>Transpose</label>
                <input type="number" id="t-shift" min="-7" max="7" step="1" value="0">
            </div>
            <div class="btn-group">
                <button class="btn-full btn-danger" onclick="deleteTrigger()">DELETE</button>
                <button class="btn-full" onclick="closePanel('trigger-panel')">DONE</button>
            </div>
        </div>

        <div id="orb-panel" class="modal">
            <h2>Orb Settings</h2>
            <div class="control-row">
                <label>Trigger</label>
                <select id="o-trigger">
                    <option value="notes">NOTES</option>
                    <option value="gates">GATES</option>
                    <option value="circle">CIRCLE</option>
                </select>
            </div>
            <div class="control-row">
                <label>Collision</label>
                <input type="checkbox" id="o-collision">
            </div>
            <div class="btn-group">
                <button class="btn-full" onclick="closePanel('orb-panel')">DONE</button>
            </div>
        </div>

        <div id="global-panel" class="modal">
            <h2>Settings</h2>
            <div class="control-row">
                <label>Root</label>
                <select id="g-root">
                    <option value="C">C</option><option value="C#">C#</option>
                    <option value="D">D</option><option value="D#">D#</option>
                    <option value="E">E</option><option value="F">F</option>
                    <option value="F#">F#</option><option value="G">G</option>
                    <option value="G#">G#</option><option value="A">A</option>
                    <option value="A#">A#</option><option value="B">B</option>
                </select>
            </div>
            <div class="control-row">
                <label>Scale</label>
                <select id="g-scale" onchange="checkCustomScale(this.value)">
                    <option value="chromatic">Chromatic</option>
                    <option value="major">Major</option>
                    <option value="minor">Minor</option>
                    <option value="pentatonic_major">Pent Maj</option>
                    <option value="pentatonic_minor">Pent Min</option>
                    <option value="whole_tone">Whole Tone</option>
                    <option value="dorian">Dorian</option>
                    <option value="lydian">Lydian</option>
                    <option value="custom">â˜… CUSTOM</option>
                </select>
            </div>
            <div class="btn-group" style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 15px;">
                <button class="btn-full" onclick="applyGlobal()">APPLY</button>
                <button class="btn-full" onclick="closePanel('global-panel')">CLOSE</button>
            </div>
            <div class="btn-group">
                <button class="btn-full" onclick="savePattern()">SAVE .JSON</button>
                <button class="btn-full" onclick="triggerLoad()">LOAD .JSON</button>
            </div>
        </div>

        <div id="scale-editor" class="modal">
            <h2>CUSTOM SCALE</h2>
            <div class="circle-keys-container" id="circle-keys"></div>
            <div class="btn-group">
                 <button class="btn-full" onclick="finishCustomScale()">DONE</button>
            </div>
        </div>

    </div>

<script>
/** * COLOR PALETTE */
const PALETTE = [
    '#cf6325', // Orange
    '#364a59', // Blue
    '#4b8b3b', // Green
    '#333333', // Black
    '#f2c400', // Yellow
    '#6c6e6b', // Slate
    '#b7b09c', // Beige
    '#000000'  // Deep Black
];

function adjustColor(color, amount) {
    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
}

function normalizeAngle(a) {
    a = a % (2 * Math.PI);
    if (a > Math.PI) a -= 2 * Math.PI;
    if (a <= -Math.PI) a += 2 * Math.PI;
    return a;
}

/** * CORE STATE */
const STATE = {
    isRunning: false,
    isPaused: false,
    audioEnabled: true,
    masterVolume: 0.5,
    planets: [],
    triggers: [{ id: 1, angle: Math.random() * Math.PI * 2, shift: 0 }],
    orbitRadius: 200, 
    root: 'C',
    scale: 'major',
    customScale: [0,2,4,5,7,9,11], 
    editingId: null, 
    editingTriggerId: null, 
    editingOrbId: null,
    globalSpeed: 1.0,
    gateTranspose: 0,
    direction: -1,
    projectiles: [], 
    slingshot: { active: false, isDragging: false, pullX: 0, pullY: 0 },
    centerColor: 'var(--ink-color)',
    orbPanelPrevSlingshot: null,
    orbSettings: {
        triggerMode: 'notes',
        collision: false,
        velocity: 0.7
    }
};

const UNDO_LIMIT = 20;
const undoStack = [];

function createUndoSnapshot() {
    return {
        planets: STATE.planets.map(p => ({ ...p })),
        triggers: STATE.triggers.map(t => ({ ...t })),
        root: STATE.root,
        scale: STATE.scale,
        customScale: [...STATE.customScale],
        globalSpeed: STATE.globalSpeed,
        gateTranspose: STATE.gateTranspose,
        direction: STATE.direction,
        isPaused: STATE.isPaused
    };
}

function pushUndoState() {
    undoStack.push(createUndoSnapshot());
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    updateUndoButton();
}

function applyUndoSnapshot(snapshot) {
    STATE.planets = snapshot.planets.map(p => ({ ...p }));
    STATE.triggers = snapshot.triggers.map(t => ({ ...t }));
    STATE.root = snapshot.root;
    STATE.scale = snapshot.scale;
    STATE.customScale = [...snapshot.customScale];
    STATE.globalSpeed = snapshot.globalSpeed;
    STATE.gateTranspose = snapshot.gateTranspose ?? 0;
    STATE.direction = snapshot.direction;
    STATE.isPaused = snapshot.isPaused;
    STATE.orbPanelPrevSlingshot = null;

    STATE.editingId = null;
    STATE.editingTriggerId = null;
    STATE.editingOrbId = null;
    document.getElementById('planet-panel').style.display = 'none';
    document.getElementById('trigger-panel').style.display = 'none';
    document.getElementById('orb-panel').style.display = 'none';
    document.getElementById('global-panel').style.display = 'none';

    const btn = document.getElementById('btn-dir');
    const isCW = STATE.direction === 1;
    btn.innerText = isCW ? "CW" : "CCW";
    if (isCW) document.body.classList.add('dark-mode');
    else document.body.classList.remove('dark-mode');

    const speedRange = document.getElementById('speed-range');
    if (speedRange) speedRange.value = STATE.globalSpeed;
    const transposeRange = document.getElementById('transpose-range');
    if (transposeRange) transposeRange.value = STATE.gateTranspose;
    const transposeLabel = document.getElementById('transpose-label');
    if (transposeLabel) transposeLabel.innerText = STATE.gateTranspose;
    syncGateUI();
    updatePlayButton();
    updatePlanetList();
}

function undoLastMove() {
    if (undoStack.length === 0) return;
    const snapshot = undoStack.pop();
    applyUndoSnapshot(snapshot);
    updateUndoButton();
}

function updateUndoButton() {
    const btn = document.getElementById('btn-undo');
    if (!btn) return;
    btn.disabled = undoStack.length === 0;
}

/**
 * MUSIC LOGIC
 */
const MusicTheory = (() => {
    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const SCALES = {
        'chromatic': [0,1,2,3,4,5,6,7,8,9,10,11],
        'major': [0,2,4,5,7,9,11],
        'minor': [0,2,3,5,7,8,10],
        'pentatonic_major': [0,2,4,7,9],
        'pentatonic_minor': [0,3,5,7,10],
        'whole_tone': [0,2,4,6,8,10],
        'dorian': [0,2,3,5,7,9,10],
        'lydian': [0,2,4,6,7,9,11]
    };

    function getFullScale(root, scale) {
        const rootIdx = NOTES.indexOf(root);
        let interval = SCALES[scale];
        if (scale === 'custom') interval = STATE.customScale;
        if (!interval || interval.length === 0) interval = SCALES['chromatic'];

        let res = [];
        for(let oct=0; oct<=8; oct++) {
            interval.forEach(i => {
                const idx = (rootIdx + i) % 12;
                res.push(NOTES[idx] + oct);
            });
        }
        return res;
    }

    function getNotes(root, scale) {
        const all = getFullScale(root, scale);
        return all.filter(n => {
            const oct = parseInt(n.slice(-1));
            return oct >= 2 && oct <= 7;
        });
    }

    function getRandomNoteInRange(root, scale, minOct, maxOct) {
        const all = getFullScale(root, scale);
        const filtered = all.filter(n => {
            const oct = parseInt(n.slice(-1));
            return oct >= minOct && oct <= maxOct;
        });
        if(filtered.length === 0) return root + '4';
        return filtered[Math.floor(Math.random() * filtered.length)];
    }

    function getShiftedNote(root, scale, currentNote, shift) {
        if(shift === 0) return currentNote;
        const all = getFullScale(root, scale);
        const idx = all.indexOf(currentNote);
        if(idx === -1) return currentNote; 
        let newIdx = idx + shift;
        if(newIdx < 0) newIdx = 0;
        if(newIdx >= all.length) newIdx = all.length - 1;
        return all[newIdx];
    }

    return { getNotes, getRandomNoteInRange, getShiftedNote, NOTES };
})();

/**
 * AUDIO ENGINE - "Glassy Marimba" (Analyzed from Wav)
 * Features:
 * 1. Exact partial ratios extracted from user's Ableton sample.
 * 2. Stereo Unison (Left/Right Detuning) for "Richness".
 * 3. Soft Saturation to mimic analog drive.
 */
const AudioEngine = (() => {
    let ctx = null;
    let masterGain = null;
    let limiter = null;
    let saturator = null;
    let noiseBuffer = null;

    // RATIOS: Extracted from 'glassy_marimba_test.wav' analysis
    // 1.0 (Fund), 2.22 (Sharp 9th), 3.95 (2 Octaves), 5.97 (Perfect 19th)
    const PARTIALS = [1.0, 2.22, 3.95, 5.97];
    
    // DECAYS: Tuned to match the waveform (Highs decay faster)
    const DECAYS = [3.5, 1.8, 1.2, 0.8];
    
    // GAINS: Boosted the highs slightly for clarity
    const GAINS = [1.0, 0.5, 0.3, 0.15];
    
    // DETUNE AMOUNT: In Cents. Adds the "Chorus" width.
    const DETUNE_AMOUNT = 6; 
    
    // VOLUME COMP: Modal synthesis is quiet, this boosts it.
    const MAKEUP_GAIN = 45.0; 

    function init() {
        if(!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // 1. LIMITER (Safety for the massive gain)
            limiter = ctx.createDynamicsCompressor();
            limiter.threshold.value = -1.0; 
            limiter.ratio.value = 12.0;
            limiter.attack.value = 0.002;
            limiter.release.value = 0.1;

            // 2. SATURATOR (Warmth/Richness)
            saturator = ctx.createWaveShaper();
            saturator.curve = makeDistortionCurve(15); // Mild drive
            saturator.oversample = '4x';

            masterGain = ctx.createGain();
            masterGain.gain.value = 0.6; 

            // Signal Chain: Saturator -> Master -> Limiter -> Out
            saturator.connect(masterGain);
            masterGain.connect(limiter);
            limiter.connect(ctx.destination);

            // 3. MALLET NOISE BUFFER (The "Thud")
            const bufferSize = ctx.sampleRate * 0.1; // 100ms
            noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                // Pink-ish noise (simple filter)
                const white = Math.random() * 2 - 1;
                data[i] = (i > 0 ? (data[i-1] + white) * 0.5 : white); 
            }
        }
        if(ctx.state === 'suspended') ctx.resume();
    }

    // Warmth Curve Generator
    function makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    function toggle() {
        if(!ctx) init();
        STATE.audioEnabled = !STATE.audioEnabled;
        if(masterGain) {
            masterGain.gain.setTargetAtTime(STATE.audioEnabled ? 0.6 : 0, ctx.currentTime, 0.1);
        }
        document.getElementById('audio-label').innerText = STATE.audioEnabled ? "ON" : "OFF";
    }

    function playNote(note, velocity=1.0) {
        if(!ctx || !STATE.audioEnabled) return;

        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const oct = parseInt(note.slice(-1));
        const key = note.slice(0, -1);
        const idx = notes.indexOf(key);
        const midi = (oct + 1)*12 + idx;
        const fundamental = 440 * Math.pow(2, (midi-69)/12);
        const t = ctx.currentTime;

        // MALLET SOURCE
        const source = ctx.createBufferSource();
        source.buffer = noiseBuffer;
        
        // Mallet Filter (Lowpass) - Velocity sensitive
        const malletFilter = ctx.createBiquadFilter();
        malletFilter.type = "lowpass";
        malletFilter.frequency.value = 200 + (velocity * 3000); 

        // Mallet Envelope (Short decay)
        const malletGain = ctx.createGain();
        malletGain.gain.setValueAtTime(0, t);
        malletGain.gain.linearRampToValueAtTime(velocity, t + 0.002);
        malletGain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

        source.connect(malletFilter);
        malletFilter.connect(malletGain);

        // CREATE STEREO VOICES (Left & Right)
        const voices = [
            { pan: -0.5, detune: -DETUNE_AMOUNT }, // Left Voice
            { pan: 0.5, detune: DETUNE_AMOUNT }    // Right Voice
        ];

        voices.forEach(voice => {
            // Stereo Panner
            const panner = ctx.createStereoPanner();
            panner.pan.value = voice.pan;
            panner.connect(saturator); // Send to saturator

            // Create Partials for this voice
            PARTIALS.forEach((ratio, i) => {
                // Apply Detune: f * 2^(cents/1200)
                const detuneMult = Math.pow(2, voice.detune / 1200);
                const freq = fundamental * ratio * detuneMult;
                
                if (freq > ctx.sampleRate / 2) return; 

                const bandpass = ctx.createBiquadFilter();
                bandpass.type = "bandpass";
                bandpass.frequency.value = freq;
                // Q = Freq * Decay / 2 (Approx)
                bandpass.Q.value = (freq * DECAYS[i]) / 2; 

                const partialGain = ctx.createGain();
                // Lower gains slightly because we have 2 voices now
                partialGain.gain.value = (GAINS[i] * MAKEUP_GAIN) * 0.6; 

                // Graph: Mallet -> Bandpass -> Gain -> Panner
                malletGain.connect(bandpass);
                bandpass.connect(partialGain);
                partialGain.connect(panner);
            });
        });

        source.start(t);
        source.stop(t + 4.0); // Allow long ring out
    }

    return { init, toggle, playNote };
})();

/**
 * APP LOGIC
 */

const startNotes = ['C4', 'E4', 'G4', 'B4'];
const startRPMs = [8, 12, 16, 4];

for(let i=0; i<4; i++) {
    STATE.planets.push({
        id: Date.now() + i,
        note: startNotes[i],
        rpm: startRPMs[i],
        angle: Math.random() * Math.PI * 2,
        velocity: 0.8,
        color: PALETTE[i % PALETTE.length]
    });
}

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let canvasW, canvasH, centerX, centerY;

function resize() {
    canvasW = window.innerWidth;
    canvasH = window.innerHeight;
    canvas.width = canvasW;
    canvas.height = canvasH;
    centerX = canvasW/2;
    centerY = canvasH/2;
    const dim = Math.min(canvasW, canvasH);
    STATE.orbitRadius = dim * (dim < 600 ? 0.35 : 0.35);
}
window.addEventListener('resize', resize);
resize();

function toggleAudio() { AudioEngine.toggle(); }

function updateMasterVolume(value) {
    const volume = parseFloat(value) * 0.5;
    STATE.masterVolume = volume;
    AudioEngine.setVolume(volume);
}

function updatePlayButton() {
    const btn = document.getElementById('btn-play');
    if (!btn) return;
    btn.innerText = STATE.isPaused ? "PLAY" : "PAUSE";
}

function togglePlay() {
    STATE.isPaused = !STATE.isPaused;
    updatePlayButton();
}

function toggleDirection() {
    pushUndoState();
    STATE.direction *= -1;
    const btn = document.getElementById('btn-dir');
    const isCW = STATE.direction === 1;
    btn.innerText = isCW ? "CW" : "CCW";
    if(isCW) document.body.classList.add('dark-mode');
    else document.body.classList.remove('dark-mode');
}

function syncGateUI() {
    const gateCount = STATE.triggers.length;
    document.getElementById('gate-label').innerText = gateCount;
    const gateRange = document.getElementById('gate-range');
    if (gateRange) gateRange.value = gateCount;
}

function updatePlanetList() {
    const list = document.getElementById('planet-list');
    list.innerHTML = '';
    const chipSize = getComputedStyle(document.getElementById('planet-list-wrap'))
        .getPropertyValue('--chip-size')
        .trim() || '18px';
    STATE.planets.forEach(p => {
        const chip = document.createElement('div');
        chip.className = 'planet-chip';
        chip.style.backgroundColor = p.color;
        chip.style.width = `var(--chip-size, ${chipSize})`;
        chip.style.height = `var(--chip-size, ${chipSize})`;
        chip.style.borderRadius = '999px';
        if(STATE.editingId === p.id) chip.classList.add('active');
        chip.onclick = (e) => {
            e.stopPropagation(); 
            openPlanet(p);
        };
        list.appendChild(chip);
    });
}

function openGlobal() {
    document.getElementById('g-root').value = STATE.root;
    document.getElementById('g-scale').value = STATE.scale;
    document.getElementById('global-panel').style.display = 'block';
}

function applyGlobal() {
    pushUndoState();
    STATE.root = document.getElementById('g-root').value;
    STATE.scale = document.getElementById('g-scale').value;
    // TRIGGER QUANTIZATION
    quantizePlanets();
    closePanel('global-panel');
}

/* QUANTIZATION LOGIC */
function quantizePlanets() {
    // 1. Get allowed notes in new scale
    const allowedNotes = MusicTheory.getNotes(STATE.root, STATE.scale);
    
    // 2. Helper to convert Note to Midi Value for comparison
    const getMidiVal = (n) => {
        const key = n.slice(0, -1);
        const oct = parseInt(n.slice(-1));
        const idx = MusicTheory.NOTES.indexOf(key);
        return oct * 12 + idx;
    };

    // 3. Iterate planets
    STATE.planets.forEach(p => {
        const currentVal = getMidiVal(p.note);
        
        // Find closest valid note
        let closest = allowedNotes[0];
        let minDiff = 999;
        
        allowedNotes.forEach(valid => {
            const diff = Math.abs(getMidiVal(valid) - currentVal);
            if(diff < minDiff) {
                minDiff = diff;
                closest = valid;
            }
        });
        
        p.note = closest;
    });
    
    // Update UI if open
    if(STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if(p) openPlanet(p);
    }
}

/* CUSTOM SCALE LOGIC */
function checkCustomScale(val) {
    if(val === 'custom') {
        openScaleEditor();
        closePanel('global-panel');
    }
}

function openScaleEditor() {
    const container = document.getElementById('circle-keys');
    container.innerHTML = '';
    const notes = MusicTheory.NOTES;
    
    notes.forEach((n, i) => {
        const div = document.createElement('div');
        div.className = 'key-circle';
        if (n.includes('#')) div.classList.add('black-key');
        div.innerText = n;
        
        if (STATE.customScale.includes(i)) {
            div.classList.add('active');
        }

        div.onclick = () => {
            const idx = STATE.customScale.indexOf(i);
            if (idx > -1) {
                STATE.customScale.splice(idx, 1);
                div.classList.remove('active');
            } else {
                STATE.customScale.push(i);
                STATE.customScale.sort((a,b) => a-b);
                div.classList.add('active');
            }
        };
        container.appendChild(div);
    });
    
    document.getElementById('scale-editor').style.display = 'block';
}

function finishCustomScale() {
    pushUndoState();
    // Explicitly set state so openGlobal reads it correctly
    STATE.scale = 'custom';
    closePanel('scale-editor');
    openGlobal();
}

/* SLINGSHOT LOGIC */
function toggleSlingshot() {
    if (STATE.slingshot.active) {
        openOrbPanel();
        return;
    }

    STATE.slingshot.active = true;
    openOrbPanel();
}

function savePattern() {
    const data = {
        planets: STATE.planets,
        triggers: STATE.triggers,
        root: STATE.root,
        scale: STATE.scale,
        customScale: STATE.customScale,
        globalSpeed: STATE.globalSpeed,
        gateTranspose: STATE.gateTranspose,
        direction: STATE.direction
    };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "les_cercles_pattern.json");
    document.body.appendChild(downloadAnchorNode); 
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function triggerLoad() {
    document.getElementById('file-input').click();
}

function handleFileLoad(input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            STATE.planets = data.planets;
            STATE.triggers = data.triggers;
            STATE.root = data.root;
            STATE.scale = data.scale;
            if(data.customScale) STATE.customScale = data.customScale;
            STATE.globalSpeed = data.globalSpeed;
            STATE.gateTranspose = data.gateTranspose || 0;
            
            STATE.direction = data.direction || -1; 
            const isCW = STATE.direction === 1;
            document.getElementById('btn-dir').innerText = isCW ? "CW" : "CCW";
            if(isCW) document.body.classList.add('dark-mode');
            else document.body.classList.remove('dark-mode');

            const speedRange = document.getElementById('speed-range');
            if (speedRange) speedRange.value = STATE.globalSpeed;
            const transposeRange = document.getElementById('transpose-range');
            if (transposeRange) transposeRange.value = STATE.gateTranspose;
            const transposeLabel = document.getElementById('transpose-label');
            if (transposeLabel) transposeLabel.innerText = STATE.gateTranspose;
            syncGateUI();

            updatePlanetList();
            closePanel('global-panel');
            undoStack.length = 0;
            updateUndoButton();
            alert("Pattern Loaded!");
        } catch(err) {
            console.error(err);
            alert("Invalid JSON file.");
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}

function updateGlobalSpeed(val) {
    STATE.globalSpeed = parseFloat(val);
    if (STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if (p) {
             const effectiveRPM = p.rpm * STATE.globalSpeed;
             document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
             document.getElementById('p-rpm-range').value = effectiveRPM.toFixed(2);
        }
    }
}

function clampShift(value) {
    return Math.max(-7, Math.min(7, value));
}

function getEffectiveTriggerShift(shift) {
    return clampShift(shift + STATE.gateTranspose);
}

function playOrbNote(orb) {
    if (!orb.pitch) return;
    const velocity = orb.velocity ?? 0.7;
    AudioEngine.playNote(orb.pitch, velocity);
    MidiEngine.sendNote(orb.pitch, velocity);
}

function assignOrbPitch(orb) {
    orb.pitch = MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 2, 5);
}

function getRandomPaletteColor() {
    return PALETTE[Math.floor(Math.random() * PALETTE.length)];
}

function updateGlobalTranspose(val) {
    pushUndoState();
    STATE.gateTranspose = clampShift(parseInt(val, 10) || 0);
    const transposeRange = document.getElementById('transpose-range');
    if (transposeRange) transposeRange.value = STATE.gateTranspose;
    const transposeLabel = document.getElementById('transpose-label');
    if (transposeLabel) transposeLabel.innerText = STATE.gateTranspose;
    if (STATE.editingTriggerId) {
        const t = STATE.triggers.find(x => x.id === STATE.editingTriggerId);
        if (t) document.getElementById('t-shift').value = getEffectiveTriggerShift(t.shift);
    }
}

function addPlanet() {
    if(STATE.planets.length >= 32) return;
    pushUndoState();
    const randomNote = MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 3, 5);
    const newRPM = 3 + Math.random() * 15;
    const newP = {
        id: Date.now(),
        note: randomNote, 
        rpm: newRPM,
        angle: 0, 
        velocity: 0.7,
        color: PALETTE[STATE.planets.length % PALETTE.length],
        cooldown: 0
    };
    STATE.planets.push(newP);
    updatePlanetList();
    openPlanet(newP); 
}

function deleteLastPlanet() {
    if (STATE.planets.length === 0) return;
    pushUndoState();
    const removed = STATE.planets.pop();
    if (STATE.editingId === removed.id) {
        closePanel('planet-panel');
        STATE.editingId = null;
    }
    updatePlanetList();
}

function openPlanet(p) {
    closePanel('orb-panel');
    closePanel('trigger-panel');
    STATE.editingId = p.id;
    updatePlanetList(); 
    const panel = document.getElementById('planet-panel');
    const noteSel = document.getElementById('p-note');
    noteSel.innerHTML = '';
    
    const notes = MusicTheory.getNotes(STATE.root, STATE.scale);
    notes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.innerText = n;
        if(n === p.note) opt.selected = true;
        noteSel.appendChild(opt);
    });

    const effectiveRPM = p.rpm * STATE.globalSpeed;
    document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
    document.getElementById('p-rpm-range').value = effectiveRPM.toFixed(2);
    document.getElementById('p-vol').value = p.velocity;
    panel.style.display = 'block';
}

function deletePlanet() {
    if(!STATE.editingId) return;
    pushUndoState();
    STATE.planets = STATE.planets.filter(p => p.id !== STATE.editingId);
    updatePlanetList();
    closePanel('planet-panel');
}

function openTrigger(t) {
    closePanel('orb-panel');
    closePanel('planet-panel');
    STATE.editingTriggerId = t.id;
    document.getElementById('t-shift').value = getEffectiveTriggerShift(t.shift);
    document.getElementById('trigger-panel').style.display = 'block';
}

function openOrbPanel() {
    closePanel('planet-panel');
    closePanel('trigger-panel');
    STATE.editingOrbId = null;
    const panel = document.getElementById('orb-panel');
    const triggerSel = document.getElementById('o-trigger');
    const collisionToggle = document.getElementById('o-collision');

    const target = STATE.orbSettings;
    if (!target.triggerMode) target.triggerMode = 'notes';

    triggerSel.value = target.triggerMode;
    collisionToggle.checked = !!target.collision;

    if (STATE.orbPanelPrevSlingshot === null) {
        STATE.orbPanelPrevSlingshot = STATE.slingshot.active;
    }
    STATE.slingshot.active = true;
    panel.style.display = 'block';
}

function deleteTrigger() {
    if(!STATE.editingTriggerId) return;
    pushUndoState();
    STATE.triggers = STATE.triggers.filter(t => t.id !== STATE.editingTriggerId);
    closePanel('trigger-panel');
}

document.getElementById('t-shift').onchange = (e) => {
    let val = parseInt(e.target.value);
    if(val > 7) val = 7;
    if(val < -7) val = -7;
    e.target.value = val;

    const t = STATE.triggers.find(x => x.id === STATE.editingTriggerId);
    if(t) {
        pushUndoState();
        t.shift = clampShift(val - STATE.gateTranspose);
    }
};

document.getElementById('t-shift').oninput = (e) => {
    let val = parseInt(e.target.value);
    if(val > 7) e.target.value = 7;
    if(val < -7) e.target.value = -7;
};

function clearAll() {
    pushUndoState();
    STATE.planets = [];
    STATE.projectiles = []; 
    STATE.triggers = [{ id: Date.now(), angle: Math.random() * Math.PI * 2, shift: 0 }]; 
    updatePlanetList();
    syncGateUI();
}

function syncRPMs() {
    if (STATE.planets.length === 0) return;
    pushUndoState();
    const targetRPM = STATE.planets[0].rpm;
    STATE.planets.forEach(p => {
        p.rpm = targetRPM;
    });
    if (STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if (p) {
            const effectiveRPM = p.rpm * STATE.globalSpeed;
            document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
        }
    }
}

function evenSpacePlanets() {
    const count = STATE.planets.length;
    if (count === 0) return;
    pushUndoState();
    const ordered = STATE.planets.slice().sort((a, b) => a.angle - b.angle);
    ordered.forEach((p, i) => {
        p.angle = (i / count) * (Math.PI * 2);
    });
}

function updateGates(val) {
    const count = parseInt(val);
    pushUndoState();
    document.getElementById('gate-label').innerText = count;
    const previousShifts = STATE.triggers
        .slice()
        .sort((a, b) => a.angle - b.angle)
        .map(t => t.shift);
    STATE.triggers = [];
    for(let i=0; i<count; i++) {
        const angle = (i / count) * (Math.PI * 2);
        STATE.triggers.push({
            id: Date.now() + i,
            angle: angle,
            shift: previousShifts[i] ?? 0
        });
    }
}

function randomizeGateTranspose() {
    pushUndoState();
    STATE.triggers.forEach(t => {
        t.shift = Math.floor(Math.random() * 15) - 7;
    });
}

document.getElementById('p-note').onchange = (e) => {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if(p) {
        pushUndoState();
        p.note = e.target.value;
    }
};

document.getElementById('o-trigger').onchange = (e) => {
    STATE.orbSettings.triggerMode = e.target.value;
};

document.getElementById('o-collision').onchange = (e) => {
    STATE.orbSettings.collision = e.target.checked;
};

function updatePlanetRPM(inputVal) {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if (p && !isNaN(inputVal) && inputVal > 0) {
        p.rpm = inputVal / STATE.globalSpeed;
    }
}

document.getElementById('p-rpm').oninput = (e) => {
    const inputVal = parseFloat(e.target.value);
    updatePlanetRPM(inputVal);
    const range = document.getElementById('p-rpm-range');
    if (range && !isNaN(inputVal)) range.value = inputVal;
};

document.getElementById('p-rpm-range').oninput = (e) => {
    const inputVal = parseFloat(e.target.value);
    updatePlanetRPM(inputVal);
    const numberInput = document.getElementById('p-rpm');
    if (numberInput && !isNaN(inputVal)) numberInput.value = inputVal.toFixed(2);
};

document.getElementById('p-vol').oninput = (e) => {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if(p) p.velocity = parseFloat(e.target.value);
};

function closePanel(id) {
    document.getElementById(id).style.display = 'none';
    if(id === 'planet-panel') STATE.editingId = null;
    if(id === 'trigger-panel') STATE.editingTriggerId = null;
    if(id === 'orb-panel') {
        STATE.editingOrbId = null;
        if (STATE.orbPanelPrevSlingshot !== null) {
            STATE.slingshot.active = STATE.orbPanelPrevSlingshot;
            STATE.orbPanelPrevSlingshot = null;
        }
    }
    updatePlanetList();
}

// --- DRAG AND DROP PHYSICS (MOUSE + TOUCH) ---
let dragTarget = null; 
let isDragging = false;
let dragStartTime = 0;
let dragAllTriggers = false;

function handleStart(x, y, altKey = false) {
    const rect = canvas.getBoundingClientRect();
    const mx = x - rect.left;
    const my = y - rect.top;
    
    // 1. SLINGSHOT START
    if (STATE.slingshot.active) {
        const distCenter = Math.sqrt(Math.pow(mx-centerX, 2) + Math.pow(my-centerY, 2));
        if (distCenter < 30) {
            STATE.slingshot.isDragging = true;
            STATE.slingshot.pullX = mx;
            STATE.slingshot.pullY = my;
            return;
        }
    }

    const hitOrb = STATE.projectiles.find(orb => {
        const distO = Math.sqrt((mx - orb.x) * (mx - orb.x) + (my - orb.y) * (my - orb.y));
        return distO < 10;
    });

    if (hitOrb) {
        dragTarget = { type: 'orb', obj: hitOrb };
        isDragging = true;
        dragStartTime = Date.now();
        return;
    }

    // 2. PLANET DRAG
    const hitPlanet = STATE.planets.find(p => {
        const px = centerX + Math.cos(p.angle) * STATE.orbitRadius;
        const py = centerY + Math.sin(p.angle) * STATE.orbitRadius;
        const distP = Math.sqrt((mx-px)*(mx-px) + (my-py)*(my-py));
        return distP < 25; // Larger touch target
    });

    if (hitPlanet) {
        pushUndoState();
        dragTarget = { type: 'planet', obj: hitPlanet };
        isDragging = true;
        dragStartTime = Date.now();
        return; 
    }

    // 3. TRIGGER DRAG
    const dx = mx - centerX;
    const dy = my - centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (Math.abs(dist - STATE.orbitRadius) < 25) { // Larger touch target
        const angle = Math.atan2(dy, dx); 
        let normClick = angle;
        if(normClick < 0) normClick += Math.PI*2;

        const hitTrigger = STATE.triggers.find(t => {
            let tAngle = t.angle;
            if(tAngle < 0) tAngle += Math.PI*2;
            let diff = Math.abs(tAngle - normClick);
            if (diff > Math.PI) diff = 2 * Math.PI - diff;
            return diff < 0.2; // Larger tolerance
        });

        if (hitTrigger) {
            pushUndoState();
            dragTarget = { type: 'trigger', obj: hitTrigger };
            dragAllTriggers = altKey;
        } else {
            pushUndoState();
            const newT = { id: Date.now(), angle: angle, shift: 0 };
            STATE.triggers.push(newT);
            dragTarget = { type: 'trigger', obj: newT };
            dragAllTriggers = false;
        }
        isDragging = true;
        dragStartTime = Date.now();
    }
}

function handleMove(x, y) {
    const rect = canvas.getBoundingClientRect();
    const mx = x - rect.left;
    const my = y - rect.top;

    // SLINGSHOT DRAG UPDATE
    if (STATE.slingshot.isDragging) {
        STATE.slingshot.pullX = mx;
        STATE.slingshot.pullY = my;
        return;
    }

    if (isDragging && dragTarget) {
        const dx = mx - centerX;
        const dy = my - centerY;
        const newAngle = Math.atan2(dy, dx);
        
        if (dragTarget.type === 'trigger') {
            const tObj = dragTarget.obj;
            const oldAngle = tObj.angle;
            
            let dAngle = newAngle - oldAngle;
            while (dAngle <= -Math.PI) dAngle += 2*Math.PI;
            while (dAngle > Math.PI) dAngle -= 2*Math.PI;

            if (dragAllTriggers) {
                STATE.triggers.forEach(t => {
                    const oldTriggerAngle = t.angle;
                    STATE.planets.forEach(p => {
                        const pAngle = normalizeAngle(p.angle);
                        let dP = pAngle - oldTriggerAngle;
                        while (dP <= -Math.PI) dP += 2*Math.PI;
                        while (dP > Math.PI) dP -= 2*Math.PI;

                        let hit = false;
                        if (dAngle > 0 && dP > 0 && dP <= dAngle) hit = true;
                        if (dAngle < 0 && dP < 0 && dP >= dAngle) hit = true;

                        if (hit) {
                            const noteToPlay = MusicTheory.getShiftedNote(
                                STATE.root,
                                STATE.scale,
                                p.note,
                                getEffectiveTriggerShift(t.shift)
                            );
                            AudioEngine.playNote(noteToPlay, p.velocity);
                            MidiEngine.sendNote(noteToPlay, p.velocity);
                            p.flash = 1.0;
                        }
                    });
                    t.angle = oldTriggerAngle + dAngle;
                });
                tObj.angle = newAngle;
                return;
            }

            STATE.planets.forEach(p => {
                const pAngle = normalizeAngle(p.angle);
                let dP = pAngle - oldAngle;
                while (dP <= -Math.PI) dP += 2*Math.PI;
                while (dP > Math.PI) dP -= 2*Math.PI;
                
                let hit = false;
                if (dAngle > 0 && dP > 0 && dP <= dAngle) hit = true;
                if (dAngle < 0 && dP < 0 && dP >= dAngle) hit = true;

                if(hit) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        p.note,
                        getEffectiveTriggerShift(tObj.shift)
                    );
                    AudioEngine.playNote(noteToPlay, p.velocity);
                    MidiEngine.sendNote(noteToPlay, p.velocity);
                    p.flash = 1.0;
                }
            });
            tObj.angle = newAngle;
        }
        else if (dragTarget.type === 'planet') {
            const pObj = dragTarget.obj;
            const oldAngle = pObj.angle;

            let dAngle = newAngle - oldAngle;
            while (dAngle <= -Math.PI) dAngle += 2*Math.PI;
            while (dAngle > Math.PI) dAngle -= 2*Math.PI;

            STATE.triggers.forEach(t => {
                const tAngle = normalizeAngle(t.angle);
                let dT = tAngle - oldAngle;
                while (dT <= -Math.PI) dT += 2*Math.PI;
                while (dT > Math.PI) dT -= 2*Math.PI;

                let hit = false;
                if (dAngle > 0 && dT > 0 && dT <= dAngle) hit = true;
                if (dAngle < 0 && dT < 0 && dT >= dAngle) hit = true;

                if (hit) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        pObj.note,
                        getEffectiveTriggerShift(t.shift)
                    );
                    AudioEngine.playNote(noteToPlay, pObj.velocity);
                    MidiEngine.sendNote(noteToPlay, pObj.velocity);
                    pObj.flash = 1.0;
                }
            });
            pObj.angle = newAngle;
        }
    }
}

function handleEnd() {
    // RELEASE SLINGSHOT
    if (STATE.slingshot.isDragging) {
        STATE.slingshot.isDragging = false;
        
        const dx = centerX - STATE.slingshot.pullX;
        const dy = centerY - STATE.slingshot.pullY;
        const power = 4.0; 
        
        // Spawn New Orb (Limit 32)
        if (STATE.projectiles.length < 32) {
            STATE.projectiles.push({
                id: Date.now() + Math.random(),
                x: centerX,
                y: centerY,
                vx: dx * power,
                vy: dy * power,
                color: getRandomPaletteColor(),
                pitch: STATE.orbSettings.triggerMode === 'notes'
                    ? null
                    : MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 2, 5),
                cooldown: 0,
                velocity: STATE.orbSettings.velocity
            });
        }
    }

    if (isDragging) {
        const duration = Date.now() - dragStartTime;
        if (duration < 300) { 
            if (dragTarget.type === 'trigger') openTrigger(dragTarget.obj);
            if (dragTarget.type === 'planet') openPlanet(dragTarget.obj);
            if (dragTarget.type === 'orb') openOrbPanel();
        }
    }
    isDragging = false;
    dragTarget = null;
    dragAllTriggers = false;
}

// MOUSE EVENTS
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, e.altKey));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', handleEnd);

// TOUCH EVENTS
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    handleStart(e.touches[0].clientX, e.touches[0].clientY, false);
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    handleMove(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    handleEnd();
}, {passive: false});


let lastTime = 0;
function loop(time) {
    requestAnimationFrame(loop);
    
    if (lastTime === 0 || (time - lastTime) > 1000) {
        lastTime = time;
        return; 
    }
    const dt = (time - lastTime) / 1000;
    lastTime = time;
    
    // === PROJECTILE PHYSICS ===
    STATE.projectiles.forEach(orb => {
        orb.x += orb.vx * dt;
        orb.y += orb.vy * dt;
        if (orb.cooldown > 0) orb.cooldown -= dt;

        // CIRCULAR BOUNDARY COLLISION
        const dx = orb.x - centerX;
        const dy = orb.y - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const limit = STATE.orbitRadius - 5; 

        if (dist > limit) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            const dot = orb.vx * nx + orb.vy * ny;
            orb.vx = orb.vx - 2 * dot * nx;
            orb.vy = orb.vy - 2 * dot * ny;
            
            orb.x = centerX + nx * limit;
            orb.y = centerY + ny * limit;

            if (STATE.orbSettings.triggerMode === 'circle') {
                if (!orb.pitch) assignOrbPitch(orb);
                if (orb.cooldown <= 0) {
                    playOrbNote(orb);
                    orb.cooldown = 0.2;
                }
            }
        }

        if (STATE.orbSettings.triggerMode === 'gates') {
            if (!orb.pitch) assignOrbPitch(orb);
            for (const tObj of STATE.triggers) {
                const tx = centerX + Math.cos(tObj.angle) * STATE.orbitRadius;
                const ty = centerY + Math.sin(tObj.angle) * STATE.orbitRadius;
                const distT = Math.sqrt((orb.x - tx) * (orb.x - tx) + (orb.y - ty) * (orb.y - ty));
                if (distT < 12 && orb.cooldown <= 0) {
                    playOrbNote(orb);
                    orb.cooldown = 0.2;
                    break;
                }
            }
        }

        // Collision Check with Planets
        if (STATE.orbSettings.triggerMode === 'notes') {
            STATE.planets.forEach(p => {
                if(p.cooldown > 0) p.cooldown -= dt; 

                const px = centerX + Math.cos(p.angle) * STATE.orbitRadius;
                const py = centerY + Math.sin(p.angle) * STATE.orbitRadius;
                const distP = Math.sqrt(Math.pow(orb.x - px, 2) + Math.pow(orb.y - py, 2));
                
                if (distP < 15 && (!p.cooldown || p.cooldown <= 0)) {
                    AudioEngine.playNote(p.note, p.velocity);
                    MidiEngine.sendNote(p.note, p.velocity);
                    p.flash = 1.0;
                    STATE.centerColor = p.color;
                    orb.color = p.color; 
                    p.cooldown = 0.2; 
                }
            });
        }
    });

    if (STATE.orbSettings.collision) {
        for (let i = 0; i < STATE.projectiles.length; i++) {
            const orbA = STATE.projectiles[i];
            for (let j = i + 1; j < STATE.projectiles.length; j++) {
                const orbB = STATE.projectiles[j];
                const dx = orbB.x - orbA.x;
                const dy = orbB.y - orbA.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = 10;
                if (dist === 0 || dist >= minDist) continue;

                const nx = dx / dist;
                const ny = dy / dist;
                const rv = (orbA.vx - orbB.vx) * nx + (orbA.vy - orbB.vy) * ny;
                if (rv > 0) {
                    const impulse = rv;
                    orbA.vx -= impulse * nx;
                    orbA.vy -= impulse * ny;
                    orbB.vx += impulse * nx;
                    orbB.vy += impulse * ny;
                }

                const overlap = (minDist - dist) / 2;
                orbA.x -= nx * overlap;
                orbA.y -= ny * overlap;
                orbB.x += nx * overlap;
                orbB.y += ny * overlap;
                if (STATE.orbSettings.triggerMode !== 'notes') {
                    assignOrbPitch(orbA);
                    assignOrbPitch(orbB);
                }
                orbA.color = getRandomPaletteColor();
                orbB.color = getRandomPaletteColor();
            }
        }
    }

    // === SEQUENCER PHYSICS ===
    STATE.planets.forEach(p => {
        if (dragTarget && dragTarget.type === 'planet' && dragTarget.obj === p) {
        } 
        else if (STATE.isRunning && !STATE.isPaused) {
            const currentRPM = p.rpm * STATE.globalSpeed;
            const speed = (currentRPM * Math.PI * 2) / 60;
            const prevAngle = p.angle;
            
            p.angle += speed * STATE.direction * dt;
            
            let normAngle = p.angle % (Math.PI*2);
            if(normAngle < 0) normAngle += Math.PI*2;
            
            let prevNorm = prevAngle % (Math.PI*2);
            if(prevNorm < 0) prevNorm += Math.PI*2;
            
            STATE.triggers.forEach(trig => {
                let t = trig.angle % (Math.PI*2);
                if(t < 0) t += Math.PI*2;
                
                let didCross = false;
                
                if (STATE.direction === -1) {
                    if (prevNorm > t && normAngle <= t) {
                         if (Math.abs(prevNorm - normAngle) < Math.PI) didCross = true;
                    }
                    if (prevNorm < normAngle) { 
                        if ( (t < prevNorm) || (t > normAngle) ) didCross = true;
                    }
                } else {
                    if (prevNorm < t && normAngle >= t) {
                         if (Math.abs(prevNorm - normAngle) < Math.PI) didCross = true;
                    }
                    if (prevNorm > normAngle) {
                        if ( (t > prevNorm) || (t < normAngle) ) didCross = true;
                    }
                }
                
                if (didCross) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        p.note,
                        getEffectiveTriggerShift(trig.shift)
                    );
                    AudioEngine.playNote(noteToPlay, p.velocity);
                    MidiEngine.sendNote(noteToPlay, p.velocity);
                    p.flash = 1.0;
                }
            });
        }
    });

    // === DRAWING ===
    ctx.clearRect(0,0,canvasW,canvasH);
    
    // Draw Center / Slingshot
    if (STATE.slingshot.active) {
        ctx.beginPath();
        if (STATE.slingshot.isDragging) {
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(STATE.slingshot.pullX, STATE.slingshot.pullY);
            ctx.strokeStyle = STATE.centerColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(STATE.slingshot.pullX, STATE.slingshot.pullY, 8, 0, Math.PI*2);
            ctx.fillStyle = STATE.centerColor;
            ctx.fill();
        } else {
            ctx.arc(centerX, centerY, 8, 0, Math.PI*2);
            ctx.fillStyle = STATE.centerColor;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI*2);
            ctx.strokeStyle = STATE.centerColor;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw Projectiles
    STATE.projectiles.forEach(orb => {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, 5, 0, Math.PI*2);
        ctx.fillStyle = orb.color;
        ctx.fill();
    });
    
    // Triggers
    STATE.triggers.forEach(tObj => {
        const t = tObj.angle;
        const tx = centerX + Math.cos(t) * (STATE.orbitRadius + 15);
        const ty = centerY + Math.sin(t) * (STATE.orbitRadius + 15);
        const txIn = centerX + Math.cos(t) * (STATE.orbitRadius - 15);
        const tyIn = centerY + Math.sin(t) * (STATE.orbitRadius - 15);
        const effectiveShift = getEffectiveTriggerShift(tObj.shift);
        
        ctx.beginPath();
        ctx.moveTo(txIn, tyIn);
        ctx.lineTo(tx, ty);
        ctx.lineWidth = 6;

        if (effectiveShift === 0) {
             ctx.strokeStyle = '#f04e23'; 
             ctx.lineWidth = 4;
        } else if (effectiveShift > 0) {
             const lightenAmount = (effectiveShift - 1) * 15;
             ctx.strokeStyle = adjustColor('#cf6325', lightenAmount);
        } else {
             const darkenAmount = (effectiveShift + 1) * 15;
             ctx.strokeStyle = adjustColor('#364a59', darkenAmount);
        }
        
        ctx.stroke();
    });

    // Main Orbit
    ctx.beginPath();
    ctx.arc(centerX, centerY, STATE.orbitRadius, 0, Math.PI*2);
    ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--ink-color');
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Planets
    STATE.planets.forEach((p, i) => {
        const x = centerX + Math.cos(p.angle) * STATE.orbitRadius;
        const y = centerY + Math.sin(p.angle) * STATE.orbitRadius;
        
        if(p.flash > 0) {
            ctx.beginPath();
            ctx.arc(x, y, 25 * p.flash, 0, Math.PI*2);
            ctx.strokeStyle = p.color;
            ctx.globalAlpha = p.flash;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalAlpha = 1;
            p.flash -= 4 * dt; 
        }

        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI*2);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        if (dragTarget && dragTarget.type === 'planet' && dragTarget.obj === p) {
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#fff'; 
        } else {
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fff';
        }
        ctx.stroke();
    });
}

document.getElementById('start-overlay').addEventListener('click', () => {
    AudioEngine.init();
    MidiEngine.init();
    updatePlanetList();
    STATE.isRunning = true;
    lastTime = 0; 
    document.getElementById('start-overlay').style.display = 'none';
    updatePlayButton();
    requestAnimationFrame(loop);
});

// Touch to start overlay
document.getElementById('start-overlay').addEventListener('touchstart', (e) => {
    e.preventDefault();
    document.getElementById('start-overlay').click();
}, {passive: false});

</script>
</body>
</html>
