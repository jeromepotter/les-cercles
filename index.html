<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LES CERCLES</title>
    <style>
        :root {
            /* LIGHT MODE (Default) */
            --bg-color: #e8e6e1; 
            --ink-color: #333333; 
            --accent-orange: #cf6325;
            --accent-blue: #364a59;
            --accent-red: #f04e23;
            --panel-bg: #f4f4f2;
            --border: 1px solid #bbb;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
            --slider-pill-bg: rgba(0,0,0,0.12);
            --slider-pill-border: rgba(0,0,0,0.08);
        }

        /* DARK MODE overrides */
        body.dark-mode {
            --bg-color: #1a1a1a; 
            --ink-color: #e0e0e0;
            --panel-bg: #2a2a2a;
            --border: 1px solid #444;
            --shadow: 0 4px 10px rgba(0,0,0,0.4);
            --slider-pill-bg: rgba(255,255,255,0.12);
            --slider-pill-border: rgba(255,255,255,0.12);
        }

        @font-face {
            font-family: 'Helvetica Neue';
            src: local('Helvetica Neue'), local('Arial'), sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--ink-color);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden; /* Prevent scroll */
            width: 100vw;
            height: 100dvh;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.3s, color 0.3s;
            touch-action: manipulation;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
        }

        canvas {
            cursor: crosshair;
            touch-action: none; 
        }

        /* HUD & UI */
        #hud-top {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: 500;
            letter-spacing: 0.5px;
            z-index: 10;
            justify-content: space-between;
        }

        .hud-group {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        h1.title {
            margin: 0;
            font-weight: 700;
            font-size: 1.2em;
            letter-spacing: 1px;
            display: none; 
        }
        @media (min-width: 768px) {
            h1.title { display: block; }
        }

        .hud-item {
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        .hud-item:hover { opacity: 1; }

        select.midi-select {
            background: transparent;
            color: var(--ink-color);
            border: none;
            border-bottom: 1px solid #999;
            padding: 2px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            margin-left: 0;
            outline: none;
            max-width: 120px;
            cursor: pointer;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .hud-orb-panel {
            width: 200px;
        }

        /* CONTROLS BAR */
        #controls-bar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            pointer-events: none; 
            z-index: 20;
        }

        .controls-row {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .macro-slider-container label {
            font-size: 0.85em;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .gate-settings {
            border: none;
            padding: 0;
            display: flex;
            gap: 12px;
            align-items: center;
            pointer-events: auto;
        }

        /* BUTTONS */
        .btn-circle {
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            border-radius: 50%;
            color: var(--ink-color);
            font-size: 1.8em;
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0.8;
            border: 1px solid rgba(0,0,0,0.1); 
            transition: opacity 0.2s, transform 0.1s;
        }
        .btn-circle:active { transform: scale(0.95); background: rgba(0,0,0,0.05); }

        .btn-text {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            font-weight: 600;
            color: var(--ink-color);
            opacity: 0.7;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 1px;
            padding: 8px 10px; 
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-fixed {
            min-width: 64px;
            text-align: center;
        }
        .btn-text:active { background: rgba(0,0,0,0.05); opacity: 1; }
        .btn-active { color: var(--accent-orange); opacity: 1; border-bottom: 2px solid var(--accent-orange); }
        .btn-text:disabled { opacity: 0.3; cursor: not-allowed; }

        .btn-small {
            font-size: 0.75em;
            padding: 6px 10px;
        }

        .control-buttons-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 6px;
        }

        details.side-panel {
            pointer-events: auto;
            width: 260px;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 16px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(6px);
        }

        details.side-panel summary {
            list-style: none;
            cursor: pointer;
            font-size: 0.85em;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
            opacity: 0.7;
            display: flex;
            align-items: center;
            justify-content: space-between;
            -webkit-tap-highlight-color: transparent;
        }

        details.side-panel summary::-webkit-details-marker {
            display: none;
        }

        .side-panel-content {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #side-controls {
            position: absolute;
            inset: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 20;
        }

        #planet-list-wrap {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* PLANET LIST */
        #planet-list-wrap {
            --chip-size: 18px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 90vw;
            overflow-x: auto;
            z-index: 15;
            overflow: hidden; 
        }

        #planet-list-wrap .planet-chip-btn {
            width: var(--chip-size, 16px);
            height: var(--chip-size, 16px);
            aspect-ratio: 1 / 1;
            flex: 0 0 var(--chip-size, 16px);
            box-sizing: border-box;
            border-radius: 999px;
            border: 1px solid rgba(0,0,0,0.2);
            background: var(--panel-bg);
            color: var(--ink-color);
            font-size: 0.9em;
            line-height: 1;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        #planet-list {
            display: flex;
            gap: 8px;
            align-items: center;
            max-width: 100%;
            overflow-x: auto;
            padding: 6px; 
            scrollbar-width: none; 

        }

        .planet-chip {
            width: var(--chip-size, 16px);
            height: var(--chip-size, 16px);
            aspect-ratio: 1 / 1;
            flex: 0 0 var(--chip-size, 16px);
            box-sizing: border-box;
            border-radius: 999px;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.1);
            transition: transform 0.2s;
            flex-shrink: 0;
            display: inline-block;
        }
        .planet-chip.active { box-shadow: 0 0 0 2px var(--ink-color); transform: scale(1.3); }

        #transpose-label {
            display: inline-block;
            width: 3ch;
            text-align: center;
        }

        /* SLIDERS */
        .macro-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 100%;
            background: transparent;
            outline: none;
            cursor: pointer;
            position: absolute;
            inset: 0;
            margin: 0;
            z-index: 2;
            -webkit-tap-highlight-color: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]:focus-visible {
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: transparent;
            box-shadow: none;
            opacity: 0;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 100%;
            background: transparent;
        }
        input[type=range]::-moz-range-track {
            height: 100%;
            background: transparent;
        }
        input[type=range]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            opacity: 0;
        }
        input[type=range]::-moz-focus-outer { border: 0; }

        .slider-pill {
            position: relative;
            width: 190px;
            height: 40px;
            border-radius: 999px;
            background: linear-gradient(
                to right,
                rgba(0,0,0,0.22) 0%,
                rgba(0,0,0,0.22) var(--slider-fill, 0%),
                var(--slider-pill-bg) var(--slider-fill, 0%),
                var(--slider-pill-bg) 100%
            );
            border: 1px solid var(--slider-pill-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            box-sizing: border-box;
            overflow: hidden;
            font-size: 0.8em;
            letter-spacing: 0.3px;
            font-weight: 600;
        }

        .slider-pill__label,
        .slider-pill__value {
            z-index: 1;
            pointer-events: none;
        }

        .slider-pill__value {
            opacity: 0.7;
        }

        .slider-pill--compact {
            width: 150px;
            height: 34px;
            font-size: 0.7em;
        }

        /* PANELS */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: var(--panel-bg);
            border: var(--border);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            padding: 20px;
            z-index: 100;
            border-radius: 4px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        #global-panel {
            position: absolute;
            top: 0;
            left: 0;
            transform: none;
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.12);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 90;
        }

        #modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal h2 {
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
            color: var(--ink-color);
            opacity: 0.6;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        input:not([type=range]), select {
            background: var(--bg-color);
            color: var(--ink-color);
            border: 1px solid #ccc;
            padding: 8px;
            font-family: inherit;
            width: 120px;
            border-radius: 3px;
            font-size: 16px; 
        }
        input[type=checkbox] { width: auto; }

        .btn-group { display: flex; gap: 10px; margin-top: 25px; }
        .btn-full { flex: 1; padding: 12px; cursor: pointer; border: 1px solid #ccc; background: var(--bg-color); color: var(--ink-color); font-weight: 600; font-size: 0.9em; border-radius: 3px; }
        .btn-danger { color: #d00; border-color: #ecc; }

        /* CIRCLE KEYS */
        .circle-keys-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0; }
        .key-circle {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid var(--ink-color);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            font-size: 0.75em; font-weight: bold; opacity: 1; background: #fff; color: var(--ink-color);
        }
        .key-circle.active { background: #000; color: #fff; opacity: 1; }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000; cursor: pointer;
        }

        /* --- MOBILE OPTIMIZATIONS --- */
        @media (max-width: 768px) {
            #hud-top { 
                top: 10px; left: 10px; right: 10px; 
                gap: 5px;
            }
            .hud-item { font-size: 0.75em; }
            .hud-group { gap: 8px; }
            .hud-orb-panel { width: 170px; }
            
            select.midi-select {
                max-width: 80px;
                font-size: 0.9em;
                padding: 0;
                border: none;
                border-bottom: 1px solid #999;
            }

            #controls-bar {
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                background: rgba(255,255,255,0.1);
                backdrop-filter: blur(10px);
                padding: 10px 5px 15px 5px; 
                flex-direction: column-reverse; 
                gap: 12px;
                border-top: 1px solid rgba(0,0,0,0.05);
                box-sizing: border-box;
            }

            .control-group {
                width: 100%;
                justify-content: center; 
                flex-wrap: wrap;
                gap: 8px 6px;
            }
            
            .slider-pill { width: 160px; height: 34px; font-size: 0.7em; }
            .slider-pill--compact { width: 130px; height: 30px; }
            .macro-slider-container label { font-size: 0.7em !important; }

            .btn-text {
                font-size: 0.7em;
                padding: 8px 6px;
                border: 1px solid rgba(0,0,0,0.1);
            }
            
            #controls-bar {
                bottom: 15px;
                left: 10px;
                right: 10px;
            }

            .controls-row {
                flex-direction: column;
                gap: 10px;
            }

            .gate-settings {
                flex-wrap: wrap;
                justify-content: center;
            }

            #side-controls {
                inset: auto 10px 120px;
                flex-direction: column;
                gap: 12px;
            }

            details.side-panel {
                width: 100%;
                max-width: 320px;
            }

            #planet-list-wrap {
                bottom: 240px;
            }

            .side-panel-content {
                max-height: 40vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .modal { width: 85vw; }
            #global-panel {
                top: 50%;
                left: 50%;
                right: auto;
                transform: translate(-50%, -50%);
            }
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-size: 3em; letter-spacing: 4px; font-weight: 300; text-align: center;">LES CERCLES</h1>
        <p style="color: var(--ink-color); opacity: 0.5; margin-top: 10px; font-size: 0.8em;">CLICK TO INITIALIZE</p>
    </div>

    <input type="file" id="file-input" style="display: none;" accept=".json" onchange="handleFileLoad(this)">

    <div id="game-container">
        <div id="hud-top">
            <div class="hud-group">
                <h1 class="title">LES CERCLES</h1>
                <div class="hud-item" onclick="toggleAudio()">AUDIO: <span id="audio-label">ON</span></div>
            <div class="hud-item" id="settings-button" onclick="openGlobal()">SETTINGS</div>
            </div>

            <div class="hud-group">
                <div class="hud-item">
                    <select id="midi-select" class="midi-select" onchange="MidiEngine.selectOutput(this.value)">
                        <option value="">MIDI...</option>
                    </select>
                </div>

                <div class="hud-item volume-control">
                    <div class="slider-pill slider-pill--compact">
                        <span class="slider-pill__label">Volume</span>
                        <span class="slider-pill__value" id="volume-value">100%</span>
                        <input id="volume-range" type="range" min="0" max="2" step="0.01" value="1" data-value-target="volume-value" data-format="percent" oninput="updateMasterVolume(this.value); updateSliderValue(this)">
                    </div>
                </div>

            </div>
        </div>

        <canvas id="mainCanvas"></canvas>
        <div id="modal-overlay" onclick="closePanel('global-panel')"></div>
        
        <div id="planet-list-wrap">
            <button class="planet-chip-btn" onclick="addPlanet()">+</button>
            <div id="planet-list"></div>
            <button class="planet-chip-btn" onclick="deleteLastPlanet()">-</button>
        </div>

        <div id="side-controls">
            <details class="side-panel" id="notes-panel">
                <summary>NOTES</summary>
                <div class="side-panel-content">
                    <button id="btn-dir" class="btn-text" onclick="toggleDirection()">CCW</button>
                    <button class="btn-text" onclick="syncRPMs()">SYNC</button>
                    <button class="btn-text" onclick="evenSpacePlanets()">EVEN</button>
                    <button id="btn-play" class="btn-text btn-fixed" onclick="togglePlay()">PLAY</button>

                    <div class="macro-slider-container">
                        <div class="slider-pill">
                            <span class="slider-pill__label">Speed</span>
                            <span class="slider-pill__value" id="speed-value">1.0x</span>
                            <input id="speed-range" type="range" min="0.1" max="3.0" step="0.1" value="1.0" data-value-target="speed-value" data-format="speed" oninput="updateGlobalSpeed(this.value); updateSliderValue(this)">
                        </div>
                    </div>

                </div>
            </details>

            <details class="side-panel" id="gates-panel">
                <summary>GATES</summary>
                <div class="side-panel-content">
                    <button id="btn-gate-play" class="btn-text btn-fixed" onclick="toggleGateSpin()">PLAY</button>

                    <div class="macro-slider-container">
                        <div class="slider-pill">
                            <span class="slider-pill__label">Gates</span>
                            <span class="slider-pill__value" id="gate-label">1</span>
                            <input id="gate-range" type="range" min="1" max="32" step="1" value="1" data-value-target="gate-label" data-format="int" oninput="updateGates(this.value); updateSliderValue(this)">
                        </div>
                    </div>

                    <button class="btn-text" onclick="randomizeGateTranspose()">RND TRNS</button>
                    <button class="btn-text" onclick="randomizeGateSpacing()">RND SPC</button>

                    <div class="macro-slider-container">
                        <div class="slider-pill">
                            <span class="slider-pill__label">Gate Speed</span>
                            <span class="slider-pill__value" id="gate-speed-label">10 RPM</span>
                            <input id="gate-speed-range" type="range" min="1" max="60" step="1" value="10" data-value-target="gate-speed-label" data-format="rpm" oninput="updateGateSpinSpeed(this.value); updateSliderValue(this)">
                        </div>
                    </div>

                    <div class="macro-slider-container">
                        <div class="slider-pill">
                            <span class="slider-pill__label">Transpose</span>
                            <span class="slider-pill__value" id="transpose-label">0</span>
                            <input id="transpose-range" type="range" min="-7" max="7" step="1" value="0" data-value-target="transpose-label" data-format="signed" oninput="updateGlobalTranspose(this.value); updateSliderValue(this)">
                        </div>
                        <div class="control-buttons-row">
                            <button class="btn-text btn-small" onclick="adjustGlobalTranspose(-1)">-1</button>
                            <button class="btn-text btn-small" onclick="adjustGlobalTranspose(1)">+1</button>
                        </div>
                    </div>

                    <button id="btn-gate-dir" class="btn-text" onclick="toggleGateSpinDirection()">CW</button>
                </div>
            </details>

            <details class="side-panel" id="orbs-panel">
                <summary>ORBS</summary>
                <div class="side-panel-content">
                    <div class="control-row">
                        <label>Trigger</label>
                        <select id="o-trigger-inline">
                            <option value="notes">NOTES</option>
                            <option value="gates">GATES</option>
                            <option value="circle">CIRCLE</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Collision</label>
                        <input type="checkbox" id="o-collision-inline">
                    </div>
                    <button class="btn-text" onclick="toggleSlingshotArm()">ARM ORB</button>
                </div>
            </details>
        </div>

        <div id="planet-panel" class="modal">
            <div class="control-row">
                <label>Note</label>
                <select id="p-note"></select>
            </div>
            <div class="control-row">
                <label>RPM</label>
                <input type="number" id="p-rpm" step="0.1" min="0.1" max="100">
            </div>
            <div class="control-row">
                <div class="slider-pill">
                    <span class="slider-pill__label">RPM</span>
                    <span class="slider-pill__value" id="p-rpm-value">0.00</span>
                    <input type="range" id="p-rpm-range" min="0.1" max="100" step="0.01" data-value-target="p-rpm-value" data-format="rpm-fine">
                </div>
            </div>
            <div class="control-row">
                <div class="slider-pill">
                    <span class="slider-pill__label">Volume</span>
                    <span class="slider-pill__value" id="p-vol-value">70%</span>
                    <input type="range" id="p-vol" min="0" max="1" step="0.01" data-value-target="p-vol-value" data-format="percent-100">
                </div>
            </div>
            <div class="btn-group">
                <button class="btn-full btn-danger" onclick="deletePlanet()">DELETE</button>
                <button class="btn-full" onclick="closePanel('planet-panel')">DONE</button>
            </div>
        </div>

        <div id="trigger-panel" class="modal">
            <h2>Trigger Settings</h2>
            <div class="control-row">
                <div class="slider-pill">
                    <span class="slider-pill__label">Transpose</span>
                    <span class="slider-pill__value" id="t-shift-label">0</span>
                    <input type="range" id="t-shift-range" min="-7" max="7" step="1" value="0" data-value-target="t-shift-label" data-format="signed">
                </div>
            </div>
            <div class="btn-group">
                <button class="btn-full btn-danger" onclick="deleteTrigger()">DELETE</button>
                <button class="btn-full" onclick="closePanel('trigger-panel')">DONE</button>
            </div>
        </div>

        <div id="orb-panel" class="modal">
            <h2>Orb Settings</h2>
            <div class="control-row">
                <label>Trigger</label>
                <select id="o-trigger">
                    <option value="notes">NOTES</option>
                    <option value="gates">GATES</option>
                    <option value="circle">CIRCLE</option>
                </select>
            </div>
            <div class="control-row">
                <label>Collision</label>
                <input type="checkbox" id="o-collision">
            </div>
            <div class="btn-group">
                <button class="btn-full" onclick="closePanel('orb-panel')">DONE</button>
            </div>
        </div>

        <div id="global-panel" class="modal">
            <h2>Settings</h2>
            <div class="control-row">
                <label>Root</label>
                <select id="g-root">
                    <option value="C">C</option><option value="C#">C#</option>
                    <option value="D">D</option><option value="D#">D#</option>
                    <option value="E">E</option><option value="F">F</option>
                    <option value="F#">F#</option><option value="G">G</option>
                    <option value="G#">G#</option><option value="A">A</option>
                    <option value="A#">A#</option><option value="B">B</option>
                </select>
            </div>
            <div class="control-row">
                <label>Scale</label>
                <select id="g-scale" onchange="checkCustomScale(this.value)">
                    <option value="chromatic">Chromatic</option>
                    <option value="major">Major</option>
                    <option value="minor">Minor</option>
                    <option value="pentatonic_major">Pent Maj</option>
                    <option value="pentatonic_minor">Pent Min</option>
                    <option value="whole_tone">Whole Tone</option>
                    <option value="dorian">Dorian</option>
                    <option value="lydian">Lydian</option>
                    <option value="custom">â˜… CUSTOM</option>
                </select>
            </div>
            <div class="btn-group" style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 15px;">
                <button class="btn-full" onclick="applyGlobal()">APPLY</button>
                <button class="btn-full" onclick="closePanel('global-panel')">CLOSE</button>
            </div>
            <div class="btn-group">
                <button class="btn-full" onclick="savePattern()">SAVE .JSON</button>
                <button class="btn-full" onclick="triggerLoad()">LOAD .JSON</button>
            </div>
            <div class="btn-group">
                <button id="btn-undo" class="btn-full" onclick="undoLastMove()" disabled>UNDO</button>
                <button id="btn-redo" class="btn-full" onclick="redoLastMove()" disabled>REDO</button>
            </div>
            <div class="btn-group">
                <button class="btn-full btn-danger" onclick="clearAll()">CLEAR</button>
            </div>
        </div>

        <div id="scale-editor" class="modal">
            <h2>CUSTOM SCALE</h2>
            <div class="circle-keys-container" id="circle-keys"></div>
            <div class="btn-group">
                 <button class="btn-full" onclick="finishCustomScale()">DONE</button>
            </div>
        </div>

    </div>

<script>
/** * COLOR PALETTE */
const PALETTE = [
    '#cf6325', // Orange
    '#364a59', // Blue
    '#4b8b3b', // Green
    '#333333', // Black
    '#f2c400', // Yellow
    '#6c6e6b', // Slate
    '#b7b09c', // Beige
    '#000000'  // Deep Black
];

function adjustColor(color, amount) {
    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
}

function normalizeAngle(a) {
    a = a % (2 * Math.PI);
    if (a > Math.PI) a -= 2 * Math.PI;
    if (a <= -Math.PI) a += 2 * Math.PI;
    return a;
}

/** * CORE STATE */
const STATE = {
    isRunning: false,
    isPaused: false,
    audioEnabled: true,
    masterVolume: 0.5,
    planets: [],
    triggers: [{ id: 1, angle: Math.random() * Math.PI * 2, shift: 0 }],
    orbitRadius: 200, 
    root: 'C',
    scale: 'major',
    customScale: [0,2,4,5,7,9,11], 
    editingId: null, 
    editingTriggerId: null, 
    editingOrbId: null,
    globalSpeed: 1.0,
    gateTranspose: 0,
    direction: -1,
    gateSpinActive: false,
    gateSpinRPM: 10,
    gateSpinDirection: 1,
    projectiles: [], 
    slingshot: { active: false, isDragging: false, pullX: 0, pullY: 0 },
    centerColor: 'var(--ink-color)',
    orbPanelPrevSlingshot: null,
    orbSettings: {
        triggerMode: 'notes',
        collision: false,
        velocity: 0.7
    }
};
STATE.gateSpinDirection = STATE.direction * -1;

const UNDO_LIMIT = 20;
const undoStack = [];
const redoStack = [];

function createUndoSnapshot() {
    return {
        planets: STATE.planets.map(p => ({ ...p })),
        triggers: STATE.triggers.map(t => ({ ...t })),
        projectiles: STATE.projectiles.map(o => ({ ...o })),
        root: STATE.root,
        scale: STATE.scale,
        customScale: [...STATE.customScale],
        globalSpeed: STATE.globalSpeed,
        gateTranspose: STATE.gateTranspose,
        direction: STATE.direction,
        isPaused: STATE.isPaused,
        gateSpinActive: STATE.gateSpinActive,
        gateSpinRPM: STATE.gateSpinRPM,
        gateSpinDirection: STATE.gateSpinDirection
    };
}

function pushUndoState() {
    undoStack.push(createUndoSnapshot());
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
}

function applyUndoSnapshot(snapshot) {
    STATE.planets = snapshot.planets.map(p => ({ ...p }));
    STATE.triggers = snapshot.triggers.map(t => ({ ...t }));
    STATE.projectiles = (snapshot.projectiles || []).map(o => ({ ...o }));
    STATE.root = snapshot.root;
    STATE.scale = snapshot.scale;
    STATE.customScale = [...snapshot.customScale];
    STATE.globalSpeed = snapshot.globalSpeed;
    STATE.gateTranspose = snapshot.gateTranspose ?? 0;
    STATE.direction = snapshot.direction;
    STATE.isPaused = snapshot.isPaused;
    STATE.gateSpinActive = snapshot.gateSpinActive ?? false;
    STATE.gateSpinRPM = snapshot.gateSpinRPM ?? 10;
    STATE.gateSpinDirection = snapshot.gateSpinDirection ?? (STATE.direction * -1);
    STATE.orbPanelPrevSlingshot = null;

    STATE.editingId = null;
    STATE.editingTriggerId = null;
    STATE.editingOrbId = null;
    document.getElementById('planet-panel').style.display = 'none';
    document.getElementById('trigger-panel').style.display = 'none';
    document.getElementById('orb-panel').style.display = 'none';
    document.getElementById('global-panel').style.display = 'none';

    const btn = document.getElementById('btn-dir');
    const isCW = STATE.direction === 1;
    btn.innerText = isCW ? "CW" : "CCW";
    if (isCW) document.body.classList.add('dark-mode');
    else document.body.classList.remove('dark-mode');

    const speedRange = document.getElementById('speed-range');
    if (speedRange) speedRange.value = STATE.globalSpeed;
    const transposeRange = document.getElementById('transpose-range');
    if (transposeRange) transposeRange.value = STATE.gateTranspose;
    const transposeLabel = document.getElementById('transpose-label');
    if (transposeLabel) transposeLabel.innerText = formatSliderValue('signed', STATE.gateTranspose);
    syncGateUI();
    updateGateSpinUI();
    updatePlayButton();
    updatePlanetList();
    refreshSliderDisplays();
}

function undoLastMove() {
    if (undoStack.length === 0) return;
    redoStack.push(createUndoSnapshot());
    const snapshot = undoStack.pop();
    applyUndoSnapshot(snapshot);
    updateUndoRedoButtons();
}

function redoLastMove() {
    if (redoStack.length === 0) return;
    undoStack.push(createUndoSnapshot());
    const snapshot = redoStack.pop();
    applyUndoSnapshot(snapshot);
    updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
    const btn = document.getElementById('btn-undo');
    if (!btn) return;
    btn.disabled = undoStack.length === 0;
    const redoBtn = document.getElementById('btn-redo');
    if (redoBtn) redoBtn.disabled = redoStack.length === 0;
}

/**
 * MUSIC LOGIC
 */
const MusicTheory = (() => {
    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const SCALES = {
        'chromatic': [0,1,2,3,4,5,6,7,8,9,10,11],
        'major': [0,2,4,5,7,9,11],
        'minor': [0,2,3,5,7,8,10],
        'pentatonic_major': [0,2,4,7,9],
        'pentatonic_minor': [0,3,5,7,10],
        'whole_tone': [0,2,4,6,8,10],
        'dorian': [0,2,3,5,7,9,10],
        'lydian': [0,2,4,6,7,9,11]
    };

    function getFullScale(root, scale) {
        const rootIdx = NOTES.indexOf(root);
        let interval = SCALES[scale];
        if (scale === 'custom') interval = STATE.customScale;
        if (!interval || interval.length === 0) interval = SCALES['chromatic'];

        let res = [];
        for(let oct=0; oct<=8; oct++) {
            interval.forEach(i => {
                const idx = (rootIdx + i) % 12;
                res.push(NOTES[idx] + oct);
            });
        }
        return res;
    }

    function getNotes(root, scale) {
        const all = getFullScale(root, scale);
        return all.filter(n => {
            const oct = parseInt(n.slice(-1));
            return oct >= 2 && oct <= 7;
        });
    }

    function getRandomNoteInRange(root, scale, minOct, maxOct) {
        const all = getFullScale(root, scale);
        const filtered = all.filter(n => {
            const oct = parseInt(n.slice(-1));
            return oct >= minOct && oct <= maxOct;
        });
        if(filtered.length === 0) return root + '4';
        return filtered[Math.floor(Math.random() * filtered.length)];
    }

    function getShiftedNote(root, scale, currentNote, shift) {
        if(shift === 0) return currentNote;
        const all = getFullScale(root, scale);
        const idx = all.indexOf(currentNote);
        if(idx === -1) return currentNote; 
        let newIdx = idx + shift;
        if(newIdx < 0) newIdx = 0;
        if(newIdx >= all.length) newIdx = all.length - 1;
        return all[newIdx];
    }

    return { getNotes, getRandomNoteInRange, getShiftedNote, NOTES };
})();

/**
 * AUDIO ENGINE
 */
const AudioEngine = (() => {
    let ctx = null;
    let masterGain = null;
    let limiter = null;

    function init() {
        if(!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            limiter = ctx.createDynamicsCompressor();
            limiter.threshold.value = -1; 
            limiter.knee.value = 5;
            limiter.ratio.value = 20; 
            limiter.attack.value = 0.001; 
            limiter.release.value = 0.1;
            
            masterGain = ctx.createGain();
            masterGain.gain.value = STATE.audioEnabled ? STATE.masterVolume : 0; 

            masterGain.connect(limiter);
            limiter.connect(ctx.destination);
        }
        if(ctx.state === 'suspended') ctx.resume();
    }

    function setVolume(value) {
        if(!ctx || !masterGain) return;
        const target = STATE.audioEnabled ? value : 0;
        masterGain.gain.cancelScheduledValues(ctx.currentTime);
        masterGain.gain.setTargetAtTime(target, ctx.currentTime, 0.05);
    }

    function toggle() {
        if(!ctx) init();
        STATE.audioEnabled = !STATE.audioEnabled;
        setVolume(STATE.masterVolume);
        document.getElementById('audio-label').innerText = STATE.audioEnabled ? "ON" : "OFF";
    }

    function playNote(note, velocity=1.0) {
        if(!ctx || !STATE.audioEnabled) return;
        
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const oct = parseInt(note.slice(-1));
        const key = note.slice(0, -1);
        const idx = notes.indexOf(key);
        const midi = (oct + 1)*12 + idx;
        const freq = 440 * Math.pow(2, (midi-69)/12);

        const t = ctx.currentTime;
        const osc = ctx.createOscillator();
        const filter = ctx.createBiquadFilter();
        const gain = ctx.createGain();

        osc.type = 'triangle';
        osc.frequency.setValueAtTime(freq, t);

        const cutoff = Math.min(freq * 3, 4000); 
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(cutoff, t);
        filter.Q.value = 1; 

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(velocity, t + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + 1.3);
    }

    return { init, toggle, playNote, setVolume };
})();

/**
 * MIDI ENGINE
 */
const MidiEngine = (() => {
    let access = null;
    let selectedOutput = null;
    let selectedOutputId = "";

    async function init() {
        if(!navigator.requestMIDIAccess) return;
        try {
            access = await navigator.requestMIDIAccess();
            access.onstatechange = scan;
            scan();
        } catch(e) { console.log("MIDI Fail"); }
    }

    function scan() {
        const sel = document.getElementById('midi-select');
        sel.innerHTML = '<option value="">MIDI...</option>';
        if(!access) return;
        const currentId = selectedOutputId || sel.value;
        let matched = false;
        const iter = access.outputs.values();
        for(let o = iter.next(); !o.done; o = iter.next()) {
            const opt = document.createElement('option');
            opt.value = o.value.id;
            opt.innerText = o.value.name;
            if(currentId && o.value.id === currentId) {
                opt.selected = true;
                selectedOutput = o.value;
                selectedOutputId = currentId;
                matched = true;
            }
            sel.appendChild(opt);
        }
        if(!matched) {
            selectedOutput = null;
            selectedOutputId = "";
        }
    }

    function selectOutput(id) {
        if(!access) return;
        selectedOutputId = id;
        selectedOutput = null;
        const iter = access.outputs.values();
        for(let o = iter.next(); !o.done; o = iter.next()) {
            if(o.value.id === id) selectedOutput = o.value;
        }
    }

    function sendNote(note, velocity) {
        if(!selectedOutput) return;
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const oct = parseInt(note.slice(-1));
        const key = note.slice(0, -1);
        const idx = notes.indexOf(key);
        const midiNum = (oct + 1)*12 + idx;
        const vel = Math.floor(velocity * 127);
        try {
            selectedOutput.send([0x90, midiNum, vel]);
            setTimeout(() => selectedOutput.send([0x80, midiNum, 0]), 100);
        } catch(e){}
    }

    return { init, selectOutput, sendNote };
})();

/**
 * APP LOGIC
 */

const startNotes = ['C4', 'E4', 'G4', 'B4'];
const startRPMs = [8, 12, 16, 4];

for(let i=0; i<4; i++) {
    STATE.planets.push({
        id: Date.now() + i,
        note: startNotes[i],
        rpm: startRPMs[i],
        angle: Math.random() * Math.PI * 2,
        velocity: 0.8,
        color: PALETTE[i % PALETTE.length]
    });
}

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let canvasW, canvasH, centerX, centerY;
let isMobileLayout = null;

function resize() {
    canvasW = window.innerWidth;
    canvasH = window.innerHeight;
    canvas.width = canvasW;
    canvas.height = canvasH;
    centerX = canvasW/2;
    centerY = canvasH/2;
    const dim = Math.min(canvasW, canvasH);
    STATE.orbitRadius = dim * (dim < 600 ? 0.3 : 0.35);
    updateSidePanelsForViewport();
}
window.addEventListener('resize', resize);
resize();

function updateSidePanelsForViewport() {
    const isMobile = window.innerWidth <= 768;
    if (isMobileLayout === isMobile) return;
    isMobileLayout = isMobile;
    const notesPanel = document.getElementById('notes-panel');
    const gatesPanel = document.getElementById('gates-panel');
    const orbsPanel = document.getElementById('orbs-panel');
    if (!notesPanel || !gatesPanel || !orbsPanel) return;
    notesPanel.open = !isMobile;
    gatesPanel.open = !isMobile;
    orbsPanel.open = !isMobile;
}

function toggleAudio() { AudioEngine.toggle(); }

function updateMasterVolume(value) {
    const volume = parseFloat(value) * 0.5;
    STATE.masterVolume = volume;
    AudioEngine.setVolume(volume);
}

function syncOrbInlineControls() {
    const triggerInline = document.getElementById('o-trigger-inline');
    const collisionInline = document.getElementById('o-collision-inline');
    if (triggerInline) triggerInline.value = STATE.orbSettings.triggerMode || 'notes';
    if (collisionInline) collisionInline.checked = !!STATE.orbSettings.collision;
}

function formatSliderValue(format, value) {
    const num = parseFloat(value);
    if (Number.isNaN(num)) return value;
    switch (format) {
        case 'percent':
            return `${Math.round(num * 100)}%`;
        case 'percent-100':
            return `${Math.round(num * 100)}%`;
        case 'speed':
            return `${num.toFixed(1)}x`;
        case 'rpm':
            return `${Math.round(num)} RPM`;
        case 'rpm-fine':
            return num.toFixed(2);
        case 'signed': {
            const intVal = Math.round(num);
            return intVal > 0 ? `+${intVal}` : `${intVal}`;
        }
        case 'int':
            return `${Math.round(num)}`;
        default:
            return `${num}`;
    }
}

function updateSliderValue(input) {
    if (!input) return;
    const targetId = input.dataset.valueTarget;
    if (!targetId) return;
    const target = document.getElementById(targetId);
    if (!target) return;
    const format = input.dataset.format || 'raw';
    target.textContent = formatSliderValue(format, input.value);
    updateSliderFill(input);
}

function updateSliderFill(input) {
    const container = input.closest('.slider-pill');
    if (!container) return;
    const min = parseFloat(input.min || 0);
    const max = parseFloat(input.max || 100);
    const val = parseFloat(input.value || 0);
    const percent = max > min ? ((val - min) / (max - min)) * 100 : 0;
    const clamped = Math.max(0, Math.min(100, percent));
    container.style.setProperty('--slider-fill', `${clamped}%`);
}

function refreshSliderDisplays() {
    const ids = [
        'volume-range',
        'speed-range',
        'gate-range',
        'transpose-range',
        'gate-speed-range',
        'p-rpm-range',
        'p-vol'
    ];
    ids.forEach(id => {
        const input = document.getElementById(id);
        if (input) updateSliderValue(input);
    });
}

function updatePlayButton() {
    const btn = document.getElementById('btn-play');
    if (!btn) return;
    btn.innerText = STATE.isPaused ? "PLAY" : "PAUSE";
}

function updateGateSpinUI() {
    const btn = document.getElementById('btn-gate-play');
    if (btn) btn.innerText = STATE.gateSpinActive ? "PAUSE" : "PLAY";
    const dirBtn = document.getElementById('btn-gate-dir');
    if (dirBtn) dirBtn.innerText = STATE.gateSpinDirection === 1 ? "CW" : "CCW";
    const speedRange = document.getElementById('gate-speed-range');
    if (speedRange) {
        speedRange.value = STATE.gateSpinRPM;
        updateSliderValue(speedRange);
    }
}

const gateSpeedRange = document.getElementById('gate-speed-range');
if (gateSpeedRange) {
    const stopGateSpeedAdjust = () => { gateSpeedIsAdjusting = false; };
    gateSpeedRange.addEventListener('change', stopGateSpeedAdjust);
    gateSpeedRange.addEventListener('pointerup', stopGateSpeedAdjust);
    gateSpeedRange.addEventListener('touchend', stopGateSpeedAdjust, { passive: true });
    gateSpeedRange.addEventListener('blur', stopGateSpeedAdjust);
}

function togglePlay() {
    STATE.isPaused = !STATE.isPaused;
    updatePlayButton();
}

function toggleDirection() {
    pushUndoState();
    STATE.direction *= -1;
    const btn = document.getElementById('btn-dir');
    const isCW = STATE.direction === 1;
    btn.innerText = isCW ? "CW" : "CCW";
    if(isCW) document.body.classList.add('dark-mode');
    else document.body.classList.remove('dark-mode');
}

function toggleGateSpin() {
    pushUndoState();
    STATE.gateSpinActive = !STATE.gateSpinActive;
    updateGateSpinUI();
}

function toggleGateSpinDirection() {
    pushUndoState();
    STATE.gateSpinDirection *= -1;
    updateGateSpinUI();
}

let gateSpeedIsAdjusting = false;
function updateGateSpinSpeed(val) {
    if (!gateSpeedIsAdjusting) {
        pushUndoState();
        gateSpeedIsAdjusting = true;
    }
    STATE.gateSpinRPM = Math.min(60, Math.max(1, parseFloat(val)));
    updateGateSpinUI();
}

function syncGateUI() {
    const gateCount = STATE.triggers.length;
    document.getElementById('gate-label').innerText = gateCount;
    const gateRange = document.getElementById('gate-range');
    if (gateRange) {
        gateRange.value = gateCount;
        updateSliderValue(gateRange);
    }
}

function updatePlanetList() {
    const list = document.getElementById('planet-list');
    list.innerHTML = '';
    const chipSize = getComputedStyle(document.getElementById('planet-list-wrap'))
        .getPropertyValue('--chip-size')
        .trim() || '18px';
    STATE.planets.forEach(p => {
        const chip = document.createElement('div');
        chip.className = 'planet-chip';
        chip.style.backgroundColor = p.color;
        chip.style.width = `var(--chip-size, ${chipSize})`;
        chip.style.height = `var(--chip-size, ${chipSize})`;
        chip.style.borderRadius = '999px';
        if(STATE.editingId === p.id) chip.classList.add('active');
        chip.onclick = (e) => {
            e.stopPropagation(); 
            openPlanet(p);
        };
        list.appendChild(chip);
    });
}

function openGlobal() {
    document.getElementById('g-root').value = STATE.root;
    document.getElementById('g-scale').value = STATE.scale;
    const panel = document.getElementById('global-panel');
    const settingsButton = document.getElementById('settings-button');
    const container = document.getElementById('game-container');
    panel.style.display = 'block';
    if (window.innerWidth <= 768) {
        panel.style.top = '50%';
        panel.style.left = '50%';
        panel.style.transform = 'translate(-50%, -50%)';
    } else {
        panel.style.transform = 'none';
    }
    if (panel && settingsButton && container) {
        const btnRect = settingsButton.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const desiredTop = btnRect.bottom - containerRect.top + 8;
        const desiredLeft = btnRect.left - containerRect.left;
        const maxLeft = containerRect.width - panel.offsetWidth - 10;
        if (window.innerWidth > 768) {
            panel.style.top = `${Math.max(10, desiredTop)}px`;
            panel.style.left = `${Math.max(10, Math.min(desiredLeft, maxLeft))}px`;
        }
    }
    document.getElementById('modal-overlay').classList.add('active');
    refreshSliderDisplays();
}

function applyGlobal() {
    pushUndoState();
    STATE.root = document.getElementById('g-root').value;
    STATE.scale = document.getElementById('g-scale').value;
    // TRIGGER QUANTIZATION
    quantizePlanets();
    closePanel('global-panel');
}

/* QUANTIZATION LOGIC */
function quantizePlanets() {
    // 1. Get allowed notes in new scale
    const allowedNotes = MusicTheory.getNotes(STATE.root, STATE.scale);
    
    // 2. Helper to convert Note to Midi Value for comparison
    const getMidiVal = (n) => {
        const key = n.slice(0, -1);
        const oct = parseInt(n.slice(-1));
        const idx = MusicTheory.NOTES.indexOf(key);
        return oct * 12 + idx;
    };

    // 3. Iterate planets
    STATE.planets.forEach(p => {
        const currentVal = getMidiVal(p.note);
        
        // Find closest valid note
        let closest = allowedNotes[0];
        let minDiff = 999;
        
        allowedNotes.forEach(valid => {
            const diff = Math.abs(getMidiVal(valid) - currentVal);
            if(diff < minDiff) {
                minDiff = diff;
                closest = valid;
            }
        });
        
        p.note = closest;
    });
    
    // Update UI if open
    if(STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if(p) openPlanet(p);
    }
}

/* CUSTOM SCALE LOGIC */
function checkCustomScale(val) {
    if(val === 'custom') {
        openScaleEditor();
        closePanel('global-panel');
    }
}

function openScaleEditor() {
    const container = document.getElementById('circle-keys');
    container.innerHTML = '';
    const notes = MusicTheory.NOTES;
    
    notes.forEach((n, i) => {
        const div = document.createElement('div');
        div.className = 'key-circle';
        div.innerText = n;
        
        if (STATE.customScale.includes(i)) {
            div.classList.add('active');
        }

        div.onclick = () => {
            const idx = STATE.customScale.indexOf(i);
            if (idx > -1) {
                STATE.customScale.splice(idx, 1);
                div.classList.remove('active');
            } else {
                STATE.customScale.push(i);
                STATE.customScale.sort((a,b) => a-b);
                div.classList.add('active');
            }
        };
        container.appendChild(div);
    });
    
    document.getElementById('scale-editor').style.display = 'block';
}

function finishCustomScale() {
    pushUndoState();
    // Explicitly set state so openGlobal reads it correctly
    STATE.scale = 'custom';
    closePanel('scale-editor');
    openGlobal();
}

/* SLINGSHOT LOGIC */
function toggleSlingshot() {
    if (STATE.slingshot.active) {
        openOrbPanel();
        return;
    }

    STATE.slingshot.active = true;
    openOrbPanel();
}

function toggleSlingshotArm() {
    STATE.slingshot.active = !STATE.slingshot.active;
}

function savePattern() {
    const data = {
        planets: STATE.planets,
        triggers: STATE.triggers,
        root: STATE.root,
        scale: STATE.scale,
        customScale: STATE.customScale,
        globalSpeed: STATE.globalSpeed,
        gateTranspose: STATE.gateTranspose,
        direction: STATE.direction,
        gateSpinRPM: STATE.gateSpinRPM,
        gateSpinDirection: STATE.gateSpinDirection
    };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "les_cercles_pattern.json");
    document.body.appendChild(downloadAnchorNode); 
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function triggerLoad() {
    document.getElementById('file-input').click();
}

function handleFileLoad(input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            STATE.planets = data.planets;
            STATE.triggers = data.triggers;
            STATE.root = data.root;
            STATE.scale = data.scale;
            if(data.customScale) STATE.customScale = data.customScale;
            STATE.globalSpeed = data.globalSpeed;
            STATE.gateTranspose = data.gateTranspose || 0;
            STATE.direction = data.direction || -1; 
            const isCW = STATE.direction === 1;
            document.getElementById('btn-dir').innerText = isCW ? "CW" : "CCW";
            if(isCW) document.body.classList.add('dark-mode');
            else document.body.classList.remove('dark-mode');
            if (data.gateSpinRPM) STATE.gateSpinRPM = data.gateSpinRPM;
            if (data.gateSpinDirection) STATE.gateSpinDirection = data.gateSpinDirection;
            if (!data.gateSpinDirection) STATE.gateSpinDirection = STATE.direction * -1;

            const speedRange = document.getElementById('speed-range');
            if (speedRange) speedRange.value = STATE.globalSpeed;
            const transposeRange = document.getElementById('transpose-range');
            if (transposeRange) transposeRange.value = STATE.gateTranspose;
            const transposeLabel = document.getElementById('transpose-label');
            if (transposeLabel) transposeLabel.innerText = formatSliderValue('signed', STATE.gateTranspose);
            syncGateUI();
            updateGateSpinUI();
            refreshSliderDisplays();

            updatePlanetList();
            closePanel('global-panel');
            undoStack.length = 0;
            redoStack.length = 0;
            updateUndoRedoButtons();
            alert("Pattern Loaded!");
        } catch(err) {
            console.error(err);
            alert("Invalid JSON file.");
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}

function updateGlobalSpeed(val) {
    STATE.globalSpeed = parseFloat(val);
    if (STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if (p) {
             const effectiveRPM = p.rpm * STATE.globalSpeed;
             document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
             const rpmRange = document.getElementById('p-rpm-range');
             rpmRange.value = effectiveRPM.toFixed(2);
             updateSliderValue(rpmRange);
        }
    }
}

function clampShift(value) {
    return Math.max(-7, Math.min(7, value));
}

function clampEffectiveShift(value) {
    return Math.max(-14, Math.min(14, value));
}

function getEffectiveTriggerShift(shift) {
    return clampEffectiveShift(shift + STATE.gateTranspose);
}

function playOrbNote(orb) {
    if (!orb.pitch) return;
    const velocity = orb.velocity ?? 0.7;
    AudioEngine.playNote(orb.pitch, velocity);
    MidiEngine.sendNote(orb.pitch, velocity);
}

function assignOrbPitch(orb) {
    orb.pitch = MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 2, 5);
}

function getRandomPaletteColor() {
    return PALETTE[Math.floor(Math.random() * PALETTE.length)];
}

function updateGlobalTranspose(val) {
    pushUndoState();
    STATE.gateTranspose = clampShift(parseInt(val, 10) || 0);
    const transposeRange = document.getElementById('transpose-range');
    if (transposeRange) {
        transposeRange.value = STATE.gateTranspose;
        updateSliderValue(transposeRange);
    }
    const transposeLabel = document.getElementById('transpose-label');
    if (transposeLabel) transposeLabel.innerText = formatSliderValue('signed', STATE.gateTranspose);
    if (STATE.editingTriggerId) {
        const t = STATE.triggers.find(x => x.id === STATE.editingTriggerId);
        if (t) {
            const shiftRange = document.getElementById('t-shift-range');
            const shiftLabel = document.getElementById('t-shift-label');
            if (shiftRange) {
                shiftRange.value = clampShift(t.shift);
                updateSliderValue(shiftRange);
            }
            if (shiftLabel) shiftLabel.innerText = getEffectiveTriggerShift(t.shift);
        }
    }
}

function adjustGlobalTranspose(delta) {
    const next = clampShift((STATE.gateTranspose || 0) + delta);
    updateGlobalTranspose(next);
    const transposeRange = document.getElementById('transpose-range');
    if (transposeRange) {
        transposeRange.value = next;
        updateSliderValue(transposeRange);
    }
}

function addPlanet() {
    if(STATE.planets.length >= 32) return;
    pushUndoState();
    const randomNote = MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 3, 5);
    const newRPM = 3 + Math.random() * 15;
    const newP = {
        id: Date.now(),
        note: randomNote, 
        rpm: newRPM,
        angle: 0, 
        velocity: 0.7,
        color: PALETTE[STATE.planets.length % PALETTE.length],
        cooldown: 0
    };
    STATE.planets.push(newP);
    updatePlanetList();
    openPlanet(newP); 
}

function deleteLastPlanet() {
    if (STATE.planets.length === 0) return;
    pushUndoState();
    const removed = STATE.planets.pop();
    if (STATE.editingId === removed.id) {
        closePanel('planet-panel');
        STATE.editingId = null;
    }
    updatePlanetList();
}

function openPlanet(p) {
    closePanel('orb-panel');
    closePanel('trigger-panel');
    STATE.editingId = p.id;
    updatePlanetList(); 
    const panel = document.getElementById('planet-panel');
    const noteSel = document.getElementById('p-note');
    noteSel.innerHTML = '';
    
    const notes = MusicTheory.getNotes(STATE.root, STATE.scale);
    notes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.innerText = n;
        if(n === p.note) opt.selected = true;
        noteSel.appendChild(opt);
    });

    const effectiveRPM = p.rpm * STATE.globalSpeed;
    document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
    const rpmRange = document.getElementById('p-rpm-range');
    rpmRange.value = effectiveRPM.toFixed(2);
    updateSliderValue(rpmRange);
    const volumeRange = document.getElementById('p-vol');
    volumeRange.value = p.velocity;
    updateSliderValue(volumeRange);
    panel.style.display = 'block';
}

function deletePlanet() {
    if(!STATE.editingId) return;
    pushUndoState();
    STATE.planets = STATE.planets.filter(p => p.id !== STATE.editingId);
    updatePlanetList();
    closePanel('planet-panel');
}

function openTrigger(t) {
    closePanel('orb-panel');
    closePanel('planet-panel');
    STATE.editingTriggerId = t.id;
    const shiftRange = document.getElementById('t-shift-range');
    shiftRange.value = clampShift(t.shift);
    updateSliderValue(shiftRange);
    document.getElementById('t-shift-label').innerText = getEffectiveTriggerShift(t.shift);
    document.getElementById('trigger-panel').style.display = 'block';
}

function openOrbPanel() {
    closePanel('planet-panel');
    closePanel('trigger-panel');
    STATE.editingOrbId = null;
    const panel = document.getElementById('orb-panel');
    const triggerSel = document.getElementById('o-trigger');
    const collisionToggle = document.getElementById('o-collision');

    const target = STATE.orbSettings;
    if (!target.triggerMode) target.triggerMode = 'notes';

    triggerSel.value = target.triggerMode;
    collisionToggle.checked = !!target.collision;
    syncOrbInlineControls();

    if (STATE.orbPanelPrevSlingshot === null) {
        STATE.orbPanelPrevSlingshot = STATE.slingshot.active;
    }
    STATE.slingshot.active = true;
    panel.style.display = 'block';
}

function deleteTrigger() {
    if(!STATE.editingTriggerId) return;
    pushUndoState();
    STATE.triggers = STATE.triggers.filter(t => t.id !== STATE.editingTriggerId);
    closePanel('trigger-panel');
}

document.getElementById('t-shift-range').oninput = (e) => {
    const val = clampShift(parseInt(e.target.value, 10) || 0);
    updateSliderValue(e.target);
    const t = STATE.triggers.find(x => x.id === STATE.editingTriggerId);
    if (t) {
        pushUndoState();
        t.shift = val;
        document.getElementById('t-shift-label').innerText = getEffectiveTriggerShift(t.shift);
    }
};

function clearAll() {
    pushUndoState();
    STATE.planets = [];
    STATE.projectiles = []; 
    STATE.triggers = [{ id: Date.now(), angle: Math.random() * Math.PI * 2, shift: 0 }]; 
    updatePlanetList();
    syncGateUI();
}

function syncRPMs() {
    if (STATE.planets.length === 0) return;
    pushUndoState();
    const targetRPM = STATE.planets[0].rpm;
    STATE.planets.forEach(p => {
        p.rpm = targetRPM;
    });
    if (STATE.editingId) {
        const p = STATE.planets.find(x => x.id === STATE.editingId);
        if (p) {
            const effectiveRPM = p.rpm * STATE.globalSpeed;
            document.getElementById('p-rpm').value = effectiveRPM.toFixed(2);
        }
    }
}

function evenSpacePlanets() {
    const count = STATE.planets.length;
    if (count === 0) return;
    pushUndoState();
    const ordered = STATE.planets.slice().sort((a, b) => a.angle - b.angle);
    ordered.forEach((p, i) => {
        p.angle = (i / count) * (Math.PI * 2);
    });
}

function updateGates(val) {
    const count = parseInt(val);
    pushUndoState();
    document.getElementById('gate-label').innerText = count;
    const gateRange = document.getElementById('gate-range');
    if (gateRange) updateSliderValue(gateRange);
    const previousShifts = STATE.triggers
        .slice()
        .sort((a, b) => a.angle - b.angle)
        .map(t => t.shift);
    STATE.triggers = [];
    for(let i=0; i<count; i++) {
        const angle = (i / count) * (Math.PI * 2);
        STATE.triggers.push({
            id: Date.now() + i,
            angle: angle,
            shift: previousShifts[i] ?? 0
        });
    }
}

function randomizeGateTranspose() {
    pushUndoState();
    STATE.triggers.forEach(t => {
        t.shift = Math.floor(Math.random() * 15) - 7;
    });
    if (STATE.editingTriggerId) {
        const t = STATE.triggers.find(x => x.id === STATE.editingTriggerId);
        if (t) {
            const shiftRange = document.getElementById('t-shift-range');
            const shiftLabel = document.getElementById('t-shift-label');
            if (shiftRange) shiftRange.value = clampShift(t.shift);
            if (shiftLabel) shiftLabel.innerText = getEffectiveTriggerShift(t.shift);
        }
    }
}

function randomizeGateSpacing() {
    pushUndoState();
    STATE.triggers.forEach(t => {
        t.angle = Math.random() * Math.PI * 2;
    });
}

document.getElementById('p-note').onchange = (e) => {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if(p) {
        pushUndoState();
        p.note = e.target.value;
    }
};

document.getElementById('o-trigger').onchange = (e) => {
    STATE.orbSettings.triggerMode = e.target.value;
    syncOrbInlineControls();
};

document.getElementById('o-collision').onchange = (e) => {
    STATE.orbSettings.collision = e.target.checked;
    syncOrbInlineControls();
};

const orbTriggerInline = document.getElementById('o-trigger-inline');
if (orbTriggerInline) {
    orbTriggerInline.onchange = (e) => {
        STATE.orbSettings.triggerMode = e.target.value;
        const modalTrigger = document.getElementById('o-trigger');
        if (modalTrigger) modalTrigger.value = e.target.value;
    };
}

const orbCollisionInline = document.getElementById('o-collision-inline');
if (orbCollisionInline) {
    orbCollisionInline.onchange = (e) => {
        STATE.orbSettings.collision = e.target.checked;
        const modalCollision = document.getElementById('o-collision');
        if (modalCollision) modalCollision.checked = e.target.checked;
    };
}

function updatePlanetRPM(inputVal) {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if (p && !isNaN(inputVal) && inputVal > 0) {
        p.rpm = inputVal / STATE.globalSpeed;
    }
}

document.getElementById('p-rpm').oninput = (e) => {
    const inputVal = parseFloat(e.target.value);
    updatePlanetRPM(inputVal);
    const range = document.getElementById('p-rpm-range');
    if (range && !isNaN(inputVal)) {
        range.value = inputVal;
        updateSliderValue(range);
    }
};

document.getElementById('p-rpm-range').oninput = (e) => {
    const inputVal = parseFloat(e.target.value);
    updatePlanetRPM(inputVal);
    const numberInput = document.getElementById('p-rpm');
    if (numberInput && !isNaN(inputVal)) numberInput.value = inputVal.toFixed(2);
    updateSliderValue(e.target);
};

document.getElementById('p-vol').oninput = (e) => {
    const p = STATE.planets.find(x => x.id === STATE.editingId);
    if(p) p.velocity = parseFloat(e.target.value);
    updateSliderValue(e.target);
};

function closePanel(id) {
    document.getElementById(id).style.display = 'none';
    if (id === 'global-panel') {
        document.getElementById('modal-overlay').classList.remove('active');
    }
    if(id === 'planet-panel') STATE.editingId = null;
    if(id === 'trigger-panel') STATE.editingTriggerId = null;
    if(id === 'orb-panel') {
        STATE.editingOrbId = null;
        if (STATE.orbPanelPrevSlingshot !== null) {
            STATE.slingshot.active = STATE.orbPanelPrevSlingshot;
            STATE.orbPanelPrevSlingshot = null;
        }
    }
    updatePlanetList();
}

// --- DRAG AND DROP PHYSICS (MOUSE + TOUCH) ---
let dragTarget = null; 
let isDragging = false;
let dragStartTime = 0;
let dragAllTriggers = false;
let isSpaceDown = false;
let gateSpinKeyDirection = 0;

function shouldIgnoreKeyEvent(target) {
    if (!target) return false;
    const tagName = target.tagName;
    if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') return true;
    return target.isContentEditable;
}

function spinAllTriggers(dAngle) {
    if (!dAngle || STATE.triggers.length === 0) return;
    STATE.triggers.forEach(t => {
        const oldTriggerAngle = t.angle;
        STATE.planets.forEach(p => {
            const pAngle = normalizeAngle(p.angle);
            let dP = pAngle - oldTriggerAngle;
            while (dP <= -Math.PI) dP += 2 * Math.PI;
            while (dP > Math.PI) dP -= 2 * Math.PI;

            let hit = false;
            if (dAngle > 0 && dP > 0 && dP <= dAngle) hit = true;
            if (dAngle < 0 && dP < 0 && dP >= dAngle) hit = true;

            if (hit) {
                const noteToPlay = MusicTheory.getShiftedNote(
                    STATE.root,
                    STATE.scale,
                    p.note,
                    getEffectiveTriggerShift(t.shift)
                );
                AudioEngine.playNote(noteToPlay, p.velocity);
                MidiEngine.sendNote(noteToPlay, p.velocity);
                p.flash = 1.0;
            }
        });
        t.angle = oldTriggerAngle + dAngle;
    });
}

function handleStart(x, y, altKey = false) {
    const rect = canvas.getBoundingClientRect();
    const mx = x - rect.left;
    const my = y - rect.top;
    
    // 1. SLINGSHOT START
    if (STATE.slingshot.active) {
        const distCenter = Math.sqrt(Math.pow(mx-centerX, 2) + Math.pow(my-centerY, 2));
        if (distCenter < 30) {
            STATE.slingshot.isDragging = true;
            STATE.slingshot.pullX = mx;
            STATE.slingshot.pullY = my;
            return;
        }
    }

    const hitOrb = STATE.projectiles.find(orb => {
        const distO = Math.sqrt((mx - orb.x) * (mx - orb.x) + (my - orb.y) * (my - orb.y));
        return distO < 10;
    });

    if (hitOrb) {
        dragTarget = { type: 'orb', obj: hitOrb };
        isDragging = true;
        dragStartTime = Date.now();
        return;
    }

    // 2. PLANET DRAG
    const hitPlanet = STATE.planets.find(p => {
        const px = centerX + Math.cos(p.angle) * STATE.orbitRadius;
        const py = centerY + Math.sin(p.angle) * STATE.orbitRadius;
        const distP = Math.sqrt((mx-px)*(mx-px) + (my-py)*(my-py));
        return distP < 25; // Larger touch target
    });

    if (hitPlanet) {
        pushUndoState();
        dragTarget = { type: 'planet', obj: hitPlanet };
        isDragging = true;
        dragStartTime = Date.now();
        return; 
    }

    // 3. TRIGGER DRAG
    const dx = mx - centerX;
    const dy = my - centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (Math.abs(dist - STATE.orbitRadius) < 25) { // Larger touch target
        const angle = Math.atan2(dy, dx); 
        let normClick = angle;
        if(normClick < 0) normClick += Math.PI*2;

        const hitTrigger = STATE.triggers.find(t => {
            let tAngle = t.angle;
            if(tAngle < 0) tAngle += Math.PI*2;
            let diff = Math.abs(tAngle - normClick);
            if (diff > Math.PI) diff = 2 * Math.PI - diff;
            return diff < 0.2; // Larger tolerance
        });

        if (hitTrigger) {
            pushUndoState();
            dragTarget = { type: 'trigger', obj: hitTrigger };
            dragAllTriggers = altKey;
        } else {
            pushUndoState();
            const newT = { id: Date.now(), angle: angle, shift: 0 };
            STATE.triggers.push(newT);
            dragTarget = { type: 'trigger', obj: newT };
            dragAllTriggers = false;
        }
        isDragging = true;
        dragStartTime = Date.now();
    }
}

function handleMove(x, y) {
    const rect = canvas.getBoundingClientRect();
    const mx = x - rect.left;
    const my = y - rect.top;

    // SLINGSHOT DRAG UPDATE
    if (STATE.slingshot.isDragging) {
        STATE.slingshot.pullX = mx;
        STATE.slingshot.pullY = my;
        return;
    }

    if (isDragging && dragTarget) {
        const dx = mx - centerX;
        const dy = my - centerY;
        const newAngle = Math.atan2(dy, dx);
        
        if (dragTarget.type === 'trigger') {
            const tObj = dragTarget.obj;
            const oldAngle = tObj.angle;
            
            let dAngle = newAngle - oldAngle;
            while (dAngle <= -Math.PI) dAngle += 2*Math.PI;
            while (dAngle > Math.PI) dAngle -= 2*Math.PI;

            if (dragAllTriggers) {
                STATE.triggers.forEach(t => {
                    const oldTriggerAngle = t.angle;
                    STATE.planets.forEach(p => {
                        const pAngle = normalizeAngle(p.angle);
                        let dP = pAngle - oldTriggerAngle;
                        while (dP <= -Math.PI) dP += 2*Math.PI;
                        while (dP > Math.PI) dP -= 2*Math.PI;

                        let hit = false;
                        if (dAngle > 0 && dP > 0 && dP <= dAngle) hit = true;
                        if (dAngle < 0 && dP < 0 && dP >= dAngle) hit = true;

                        if (hit) {
                            const noteToPlay = MusicTheory.getShiftedNote(
                                STATE.root,
                                STATE.scale,
                                p.note,
                                getEffectiveTriggerShift(t.shift)
                            );
                            AudioEngine.playNote(noteToPlay, p.velocity);
                            MidiEngine.sendNote(noteToPlay, p.velocity);
                            p.flash = 1.0;
                        }
                    });
                    t.angle = oldTriggerAngle + dAngle;
                });
                tObj.angle = newAngle;
                return;
            }

            STATE.planets.forEach(p => {
                const pAngle = normalizeAngle(p.angle);
                let dP = pAngle - oldAngle;
                while (dP <= -Math.PI) dP += 2*Math.PI;
                while (dP > Math.PI) dP -= 2*Math.PI;
                
                let hit = false;
                if (dAngle > 0 && dP > 0 && dP <= dAngle) hit = true;
                if (dAngle < 0 && dP < 0 && dP >= dAngle) hit = true;

                if(hit) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        p.note,
                        getEffectiveTriggerShift(tObj.shift)
                    );
                    AudioEngine.playNote(noteToPlay, p.velocity);
                    MidiEngine.sendNote(noteToPlay, p.velocity);
                    p.flash = 1.0;
                }
            });
            tObj.angle = newAngle;
        }
        else if (dragTarget.type === 'planet') {
            const pObj = dragTarget.obj;
            const oldAngle = pObj.angle;

            let dAngle = newAngle - oldAngle;
            while (dAngle <= -Math.PI) dAngle += 2*Math.PI;
            while (dAngle > Math.PI) dAngle -= 2*Math.PI;

            STATE.triggers.forEach(t => {
                const tAngle = normalizeAngle(t.angle);
                let dT = tAngle - oldAngle;
                while (dT <= -Math.PI) dT += 2*Math.PI;
                while (dT > Math.PI) dT -= 2*Math.PI;

                let hit = false;
                if (dAngle > 0 && dT > 0 && dT <= dAngle) hit = true;
                if (dAngle < 0 && dT < 0 && dT >= dAngle) hit = true;

                if (hit) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        pObj.note,
                        getEffectiveTriggerShift(t.shift)
                    );
                    AudioEngine.playNote(noteToPlay, pObj.velocity);
                    MidiEngine.sendNote(noteToPlay, pObj.velocity);
                    pObj.flash = 1.0;
                }
            });
            pObj.angle = newAngle;
        }
    }
}

function handleEnd() {
    // RELEASE SLINGSHOT
    if (STATE.slingshot.isDragging) {
        STATE.slingshot.isDragging = false;
        
        const dx = centerX - STATE.slingshot.pullX;
        const dy = centerY - STATE.slingshot.pullY;
        const power = 4.0; 
        
        // Spawn New Orb (Limit 32)
        if (STATE.projectiles.length < 32) {
            pushUndoState();
            STATE.projectiles.push({
                id: Date.now() + Math.random(),
                x: centerX,
                y: centerY,
                vx: dx * power,
                vy: dy * power,
                color: getRandomPaletteColor(),
                pitch: STATE.orbSettings.triggerMode === 'notes'
                    ? null
                    : MusicTheory.getRandomNoteInRange(STATE.root, STATE.scale, 2, 5),
                cooldown: 0,
                velocity: STATE.orbSettings.velocity
            });
        }
    }

    if (isDragging) {
        const duration = Date.now() - dragStartTime;
        if (duration < 300) { 
            if (dragTarget.type === 'trigger') openTrigger(dragTarget.obj);
            if (dragTarget.type === 'planet') openPlanet(dragTarget.obj);
            if (dragTarget.type === 'orb') openOrbPanel();
        }
    }
    isDragging = false;
    dragTarget = null;
    dragAllTriggers = false;
}

// MOUSE EVENTS
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, e.altKey));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', handleEnd);

// TOUCH EVENTS
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    handleStart(e.touches[0].clientX, e.touches[0].clientY, false);
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    handleMove(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    handleEnd();
}, {passive: false});

window.addEventListener('keydown', e => {
    if (shouldIgnoreKeyEvent(e.target)) return;
    if (e.code === 'Space') {
        isSpaceDown = true;
        return;
    }
    if (!isSpaceDown) return;
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
        e.preventDefault();
        const direction = e.code === 'ArrowLeft' ? -1 : 1;
        if (gateSpinKeyDirection === 0) {
            pushUndoState();
        }
        gateSpinKeyDirection = direction;
    }
});

window.addEventListener('keyup', e => {
    if (e.code === 'Space') {
        isSpaceDown = false;
        gateSpinKeyDirection = 0;
    }
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
        if (gateSpinKeyDirection !== 0) gateSpinKeyDirection = 0;
    }
});


let lastTime = 0;
function loop(time) {
    requestAnimationFrame(loop);
    
    if (lastTime === 0 || (time - lastTime) > 1000) {
        lastTime = time;
        return; 
    }
    const dt = (time - lastTime) / 1000;
    lastTime = time;
    
    // === PROJECTILE PHYSICS ===
    STATE.projectiles.forEach(orb => {
        orb.x += orb.vx * dt;
        orb.y += orb.vy * dt;
        if (orb.cooldown > 0) orb.cooldown -= dt;

        // CIRCULAR BOUNDARY COLLISION
        const dx = orb.x - centerX;
        const dy = orb.y - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const limit = STATE.orbitRadius - 5; 

        if (dist > limit) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            const dot = orb.vx * nx + orb.vy * ny;
            orb.vx = orb.vx - 2 * dot * nx;
            orb.vy = orb.vy - 2 * dot * ny;
            
            orb.x = centerX + nx * limit;
            orb.y = centerY + ny * limit;

            if (STATE.orbSettings.triggerMode === 'circle') {
                if (!orb.pitch) assignOrbPitch(orb);
                if (orb.cooldown <= 0) {
                    playOrbNote(orb);
                    orb.cooldown = 0.2;
                }
            }
        }

        if (STATE.orbSettings.triggerMode === 'gates') {
            if (!orb.pitch) assignOrbPitch(orb);
            for (const tObj of STATE.triggers) {
                const tx = centerX + Math.cos(tObj.angle) * STATE.orbitRadius;
                const ty = centerY + Math.sin(tObj.angle) * STATE.orbitRadius;
                const distT = Math.sqrt((orb.x - tx) * (orb.x - tx) + (orb.y - ty) * (orb.y - ty));
                if (distT < 12 && orb.cooldown <= 0) {
                    playOrbNote(orb);
                    orb.cooldown = 0.2;
                    break;
                }
            }
        }

        // Collision Check with Planets
        if (STATE.orbSettings.triggerMode === 'notes') {
            STATE.planets.forEach(p => {
                if(p.cooldown > 0) p.cooldown -= dt; 

                const px = centerX + Math.cos(p.angle) * STATE.orbitRadius;
                const py = centerY + Math.sin(p.angle) * STATE.orbitRadius;
                const distP = Math.sqrt(Math.pow(orb.x - px, 2) + Math.pow(orb.y - py, 2));
                
                if (distP < 15 && (!p.cooldown || p.cooldown <= 0)) {
                    AudioEngine.playNote(p.note, p.velocity);
                    MidiEngine.sendNote(p.note, p.velocity);
                    p.flash = 1.0;
                    STATE.centerColor = p.color;
                    orb.color = p.color; 
                    p.cooldown = 0.2; 
                }
            });
        }
    });

    if (STATE.orbSettings.collision) {
        for (let i = 0; i < STATE.projectiles.length; i++) {
            const orbA = STATE.projectiles[i];
            for (let j = i + 1; j < STATE.projectiles.length; j++) {
                const orbB = STATE.projectiles[j];
                const dx = orbB.x - orbA.x;
                const dy = orbB.y - orbA.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = 10;
                if (dist === 0 || dist >= minDist) continue;

                const nx = dx / dist;
                const ny = dy / dist;
                const rv = (orbA.vx - orbB.vx) * nx + (orbA.vy - orbB.vy) * ny;
                if (rv > 0) {
                    const impulse = rv;
                    orbA.vx -= impulse * nx;
                    orbA.vy -= impulse * ny;
                    orbB.vx += impulse * nx;
                    orbB.vy += impulse * ny;
                }

                const overlap = (minDist - dist) / 2;
                orbA.x -= nx * overlap;
                orbA.y -= ny * overlap;
                orbB.x += nx * overlap;
                orbB.y += ny * overlap;
                if (STATE.orbSettings.triggerMode !== 'notes') {
                    assignOrbPitch(orbA);
                    assignOrbPitch(orbB);
                }
                orbA.color = getRandomPaletteColor();
                orbB.color = getRandomPaletteColor();
            }
        }
    }

    // === SEQUENCER PHYSICS ===
    if (STATE.isRunning) {
        const gateSpinRate = (STATE.gateSpinRPM * Math.PI * 2) / 60;
        if (STATE.gateSpinActive) {
            spinAllTriggers(gateSpinRate * STATE.gateSpinDirection * dt);
        }
        if (gateSpinKeyDirection !== 0) {
            spinAllTriggers(gateSpinRate * gateSpinKeyDirection * dt);
        }
    }

    STATE.planets.forEach(p => {
        if (dragTarget && dragTarget.type === 'planet' && dragTarget.obj === p) {
        } 
        else if (STATE.isRunning && !STATE.isPaused) {
            const currentRPM = p.rpm * STATE.globalSpeed;
            const speed = (currentRPM * Math.PI * 2) / 60;
            const prevAngle = p.angle;
            
            p.angle += speed * STATE.direction * dt;
            
            let normAngle = p.angle % (Math.PI*2);
            if(normAngle < 0) normAngle += Math.PI*2;
            
            let prevNorm = prevAngle % (Math.PI*2);
            if(prevNorm < 0) prevNorm += Math.PI*2;
            
            STATE.triggers.forEach(trig => {
                let t = trig.angle % (Math.PI*2);
                if(t < 0) t += Math.PI*2;
                
                let didCross = false;
                
                if (STATE.direction === -1) {
                    if (prevNorm > t && normAngle <= t) {
                         if (Math.abs(prevNorm - normAngle) < Math.PI) didCross = true;
                    }
                    if (prevNorm < normAngle) { 
                        if ( (t < prevNorm) || (t > normAngle) ) didCross = true;
                    }
                } else {
                    if (prevNorm < t && normAngle >= t) {
                         if (Math.abs(prevNorm - normAngle) < Math.PI) didCross = true;
                    }
                    if (prevNorm > normAngle) {
                        if ( (t > prevNorm) || (t < normAngle) ) didCross = true;
                    }
                }
                
                if (didCross) {
                    const noteToPlay = MusicTheory.getShiftedNote(
                        STATE.root,
                        STATE.scale,
                        p.note,
                        getEffectiveTriggerShift(trig.shift)
                    );
                    AudioEngine.playNote(noteToPlay, p.velocity);
                    MidiEngine.sendNote(noteToPlay, p.velocity);
                    p.flash = 1.0;
                }
            });
        }
    });

    // === DRAWING ===
    ctx.clearRect(0,0,canvasW,canvasH);
    
    // Draw Center / Slingshot
    if (STATE.slingshot.active) {
        ctx.beginPath();
        if (STATE.slingshot.isDragging) {
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(STATE.slingshot.pullX, STATE.slingshot.pullY);
            ctx.strokeStyle = STATE.centerColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(STATE.slingshot.pullX, STATE.slingshot.pullY, 8, 0, Math.PI*2);
            ctx.fillStyle = STATE.centerColor;
            ctx.fill();
        } else {
            ctx.arc(centerX, centerY, 8, 0, Math.PI*2);
            ctx.fillStyle = STATE.centerColor;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI*2);
            ctx.strokeStyle = STATE.centerColor;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw Projectiles
    STATE.projectiles.forEach(orb => {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, 5, 0, Math.PI*2);
        ctx.fillStyle = orb.color;
        ctx.fill();
    });
    
    // Triggers
    STATE.triggers.forEach(tObj => {
        const t = tObj.angle;
        const tx = centerX + Math.cos(t) * (STATE.orbitRadius + 15);
        const ty = centerY + Math.sin(t) * (STATE.orbitRadius + 15);
        const txIn = centerX + Math.cos(t) * (STATE.orbitRadius - 15);
        const tyIn = centerY + Math.sin(t) * (STATE.orbitRadius - 15);
        const effectiveShift = getEffectiveTriggerShift(tObj.shift);
        
        ctx.beginPath();
        ctx.moveTo(txIn, tyIn);
        ctx.lineTo(tx, ty);
        ctx.lineWidth = 6;

        if (effectiveShift === 0) {
             ctx.strokeStyle = '#f04e23'; 
             ctx.lineWidth = 4;
        } else if (effectiveShift > 0) {
             const lightenAmount = (effectiveShift - 1) * 15;
             ctx.strokeStyle = adjustColor('#cf6325', lightenAmount);
        } else {
             const darkenAmount = (effectiveShift + 1) * 15;
             ctx.strokeStyle = adjustColor('#364a59', darkenAmount);
        }
        
        ctx.stroke();
    });

    // Main Orbit
    ctx.beginPath();
    ctx.arc(centerX, centerY, STATE.orbitRadius, 0, Math.PI*2);
    ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--ink-color');
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Planets
    STATE.planets.forEach((p, i) => {
        const x = centerX + Math.cos(p.angle) * STATE.orbitRadius;
        const y = centerY + Math.sin(p.angle) * STATE.orbitRadius;
        
        if(p.flash > 0) {
            ctx.beginPath();
            ctx.arc(x, y, 25 * p.flash, 0, Math.PI*2);
            ctx.strokeStyle = p.color;
            ctx.globalAlpha = p.flash;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalAlpha = 1;
            p.flash -= 4 * dt; 
        }

        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI*2);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        if (dragTarget && dragTarget.type === 'planet' && dragTarget.obj === p) {
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#fff'; 
        } else {
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fff';
        }
        ctx.stroke();
    });
}

function initializeApp() {
    AudioEngine.init();
    MidiEngine.init();
    updatePlanetList();
    syncOrbInlineControls();
    refreshSliderDisplays();
    STATE.isRunning = true;
    lastTime = 0; 
    document.getElementById('start-overlay').style.display = 'none';
    updatePlayButton();
    updateGateSpinUI();
    requestAnimationFrame(loop);
}

document.getElementById('start-overlay').addEventListener('click', () => {
    initializeApp();
});

// Touch to start overlay
document.getElementById('start-overlay').addEventListener('touchstart', (e) => {
    e.preventDefault();
    initializeApp();
}, {passive: false});

</script>
</body>
</html>
